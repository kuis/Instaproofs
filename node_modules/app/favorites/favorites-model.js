/*==========================================================================*\
  A model for event's favourite photos
\*==========================================================================*/
"use strict";

var BaseModel = require('app/base/base-model');

var app = require('app');
var debounce = require('lodash.debounce');

var Photo = require('app/photo/photo-model').extend({
  // idAttribute: 'pid',
  // props: {
  //   pid: 'number',
  //   cat_id: 'number',
  // },
  
  // derived: {
  //   photo: { fn: function () { 
  //     return this.collection.parent.event.categories.get(this.cart_id)
  //            .photos.get(this.pid);
  //   }},
    
  //   id: { fn: function () { return this.photo.id; }},
  //   name: { fn: function () { return this.photo.name; }},
  //   img_url: { fn: function () { return this.photo.img_url; }},
  //   width: { fn: function () { return this.photo.width; }},
  //   height: { fn: function () { return this.photo.height; }},
  //   download_url: { fn: function () { return this.photo.download_url; }},
  //   pricing_id: { fn: function () { return this.photo.pricing_id; }},
    
  //   in_cart: { fn: function () { return this.photo.in_cart; }},
  //   in_favorites: { fn: function () { return this.photo.in_favorites; }},
    
  //   eid: { fn: function () { return this.photo.eid; }},
  //   event: { fn: function () { return this.photo.event; }},
  //   app_url: { fn: function () { return this.photo.app_url; }},
  //   buy_url: { fn: function () { return this.photo.buy_url; }},
  //   thumb_url: { fn: function () { return this.photo.thumb_url; }},
  //   micro_url: { fn: function () { return this.photo.micro_url; }},
  //   ratio: { fn: function () { return this.photo.ratio; }},
  //   next: { fn: function () { return this.photo.next; }},
  //   prev: { fn: function () { return this.photo.prev; }},
  //   nextAround: { fn: function () { return this.photo.nextAround; }},
  //   prevAround: { fn: function () { return this.photo.prevAround; }},
  //   pricing: { fn: function () { return this.photo.pricing; }},
  //   buyOptions: { fn: function () { return this.photo.buyOptions; }},
  // },
  
  parse: function (data, options) {
    // console.log('PARSE', data.id, data.pid);
    if (data.pid) { // convert to photo model
      var collection = (options && options.collection) || this.collection;
      var event = collection.parent.event;
      var photo = event.categories.get(data.cat_id).photos.get(data.pid);
      var attrs = photo.toJSON();
      attrs._cat_id = data.cat_id;
      // console.log('parsed', attrs);
      return attrs;
    }
    return data;
  },
  // toJSON: function () {
  //   return {
  //     pid: this.id,
  //     cat_id: this._cat_id,
  //   };
  // },
  serialize: function () {
    // console.log('serialize', this.id, this._cat_id);
    // console.trace();
    return {
      pid: this.id,
      cat_id: this._cat_id,
    };
  },
});

var PhotosCollection = require('app/base/base-collection').extend({
  // mainIndex: 'pid',
  model: Photo,
});

module.exports = BaseModel.extend({
  // extraProperties: 'ignore',
  props: {
    id: 'number',
    eid: 'number',
    mtime: ['number', true, 0], // last modification time
  },
  
  collections: {
    photos: PhotosCollection,
  },
  
  session: {
    isFavModel: ['boolean', true, true],
    isEmpty: ['boolean', true, false],
    event: 'state',
    locked: ['boolean', true, false],
  },
  
  derived: {
    name: {
      fn: function () {
        return app.view.lz('Favorites');
      },
    },
    // event: {
    //   fn: function () {
    //     return app.eventModels[this.eid];  
    //   },
    // },
    music_tracks: {
      fn: function () {
        return this.event.music || [];  
      },
    },
    app_url: {
      fn: function () {
        return '#events/'+ this.eid +'/favorites';
      },
    },
    visible_count: {
      cache: false,
      fn: function () {
        return this.photos.length;
      },
    },
  },
  
  url: function () {
    var keychain = app.keychain.events.get(this.eid);
    
    var query = '?url='+ app.url +
        (keychain && keychain.email ? 
        '&email='+ encodeURIComponent(keychain.email) : '') +
        (keychain && keychain.password ? 
        '&password='+ encodeURIComponent(keychain.password) : '');
        
    return app.apiUrl +'favorites'+ (this.isNew() ? '' : '/'+this.id) + query;
  },
  
  initialize: function (data) {
    this.save = debounce(this.save, 1000);
    this.event = data.event;
    
    this.listenTo(this.photos, 'add', function (model) {
      // this.save();
      this.isEmpty = !this.photos.length;
      this.trigger('add:'+ model.id);
      // console.log('added', model.id, this.photos.models);
    });
    this.listenTo(this.photos, 'remove', function (model) {
      // this.save();
      this.isEmpty = !this.photos.length;
      this.trigger('remove:'+ model.id);
    });
    
    this.listenTo(app, 'storage:favorites'+this.eid, this.storageCallback);
    
    if (this.event.complete) this.readStorage();
    else this.listenTo(this.event, 'change:complete', this.readStorage);
    
    this.isEmpty = !this.photos.length;
  },
  
  readStorage: function (){
    var storedData = app.storage['favorites'+this.eid];
    // if (storedData) {
    //   console.log('reading storage', JSON.parse(storedData));
    // }
    if (storedData) this.set(JSON.parse(storedData), { parse: true });
    this.isEmpty = !this.photos.length;
  },
  
  storageCallback: function (newData) {
    newData = JSON.parse(newData);
    // if (newData) console.log('reading updated storage', newData);
    if (newData.mtime > this.mtime) {
      this.set(newData, { parse: true });
      this.isEmpty = !this.photos.length;
    }
  },
  
  store: function () {
    // console.log('storing cart', 
    //     JSON.stringify(this.toJSON()).length * 2 + ' bytes');
    // console.log('storing cart', this.toJSON());
    
    // console.log('storing favs', this.photos);
    app.storage['favorites'+this.eid] = JSON.stringify(this.toJSON());
  },
  
  set: function (attrs) { // ignore ID-only data from API
    var keys = typeof attrs !== 'object' ? [attrs] : Object.keys(attrs);
    if (keys.length === 1 && keys[0] === 'id') return false;
    return BaseModel.prototype.set.apply(this, arguments);
  },
  
  save: function () {
    // console.log('saving favs', this.photos.length);
    // console.trace();
    this.mtime = Date.now();
    this.store();
    // return this.store();
    
    // var self = this;
    
    // var data = this.toJSON()
    // BaseModel.prototype.save.apply(this, arguments);
    
    return;
    
    this.sync(this.isNew() ? 'create' : 'update', this, {
      url: this.url(),
      // data: this.toJSON(),
      success: function (resp) {
          if (+resp.status !== 200) return;
        var i, j, product, model, cartProduct, newProduct;
        self.id = resp.data.id;
        for (i = 0; i < resp.data.products.length; i++) {
          product = resp.data.products[i];
          cartProduct = self.products.get(product.cart_item_id);
          if (cartProduct) continue;
          
          newProduct = [];
          for (j = 0; j < self.products.length; j++) {
            model = self.products.at(j);
            if (model.pid === product.pid && model.oid === product.oid &&
                model.qty === product.qty && model.notes === product.notes &&
                model.photos.length === product.photos.length) {
              newProduct.push(model);
            }
          }
          
          // if we don't have a perfect fit - just reset all products 
          if (newProduct.length !== 1) {
            // console.log('reset products');
            self.products.set(resp.data.products);
            break;
          }
          newProduct[0].set(product);
        }
      },
    });
    
    this.store();
  },
  
  
  updateLock: function () {
    this.locked = false;
  },
  
});
