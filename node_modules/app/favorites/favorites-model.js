/*==========================================================================*\
  A model for event's favourite photos
\*==========================================================================*/
"use strict";

var BaseModel = require('app/base/base-model');

var app = require('app');
var debounce = require('lodash.debounce');

var Photo = require('./favorite-photo');

var PhotosCollection = require('app/base/base-collection').extend({
  mainIndex: 'pid',
  model: Photo,
});


module.exports = BaseModel.extend({
  props: {
    id: 'number',
    eid: 'number',
    mtime: ['number', true, 0], // last modification time
  },
  
  collections: {
    photos: PhotosCollection,
  },
  
  session: {
    isFavModel: ['boolean', true, true],
    isEmpty: ['boolean', true, false],
    event: 'state',
    locked: ['boolean', true, false],
  },
  
  derived: {
    app_url: {
      fn: function () {
        return '#events/'+ this.eid +'/favorites';
      },
    },
    music_tracks: {
      fn: function () {
        return this.event.music || [];  
      },
    },
    name: {
      fn: function () {
        return app.view.lz('Favorites');
      },
    },
    visible_count: {
      cache: false,
      fn: function () {
        return this.photos.length;
      },
    },
  },
  
  
  initialize: function (data) {
    this.save = debounce(this.save, 1000);
    this.event = data.event;
    
    this.listenTo(this.photos, 'add', function (model) {
      this.isEmpty = !this.photos.length;
      this.trigger('add:'+ model.id);
    });
    this.listenTo(this.photos, 'remove', function (model) {
      this.isEmpty = !this.photos.length;
      this.trigger('remove:'+ model.id);
    });
    
    this.listenTo(this.event, 'fav-toggle', this.onFavToggle);
    
    this.listenTo(app, 'storage:favorites'+this.eid, this.storageCallback);
    
    if (this.event.complete) this.readStorage();
    else this.listenTo(this.event, 'change:complete', this.readStorage);
    
    this.isEmpty = !this.photos.length;
  },
  
  
  onFavToggle: function (pid, cid) {
    var favItem = this.photos.get(pid);
    if (favItem) {
      this.photos.remove(favItem);
    } 
    else {
      this.photos.add({
        pid: pid,
        cat_id: cid,
      }, { 
        parse: true,
        at: this.photos.length,
      });
    }
    this.save();
  },
  
  
  readStorage: function (){
    var storedData = app.storage['favorites'+this.eid];
    if (storedData) this.set(JSON.parse(storedData), { parse: true });
    this.isEmpty = !this.photos.length;
  },
  
  
  storageCallback: function (newData) {
    newData = JSON.parse(newData);
    if (newData.mtime > this.mtime) {
      this.set(newData, { parse: true });
      this.isEmpty = !this.photos.length;
    }
  },
  
  
  store: function () {
    app.storage['favorites'+this.eid] = JSON.stringify(this.toJSON());
  },
  
  
  getSlideshowUrl: function () {
    var photo;
    if (!this.photos.length) return '';
    for (var i = 0; i < this.photos.length; i++) {
      photo = this.photos.at(i);
      if (!photo.hidden) {
        return this.app_url +'/'+ photo.id;
      }
    }
    return '';
  },
  
  
  save: function () { // store and push to the server 
    this.mtime = Date.now();
    this.store();

    var keychain = app.keychain.events.get(this.eid);
    if (!keychain || !keychain.email) return;
    
    var self = this;

    this.sync(this.isNew() ? 'create' : 'update', this, {
      url: this.url(),
      success: function (resp) {
        if (+resp.status !== 200) return;
        self.id = resp.data.id;
        self.store();
      },
    });
  },
  
  set: function (attrs) { // ignore ID-only data from API
    var keys = typeof attrs !== 'object' ? [attrs] : Object.keys(attrs);
    if (keys.length === 1 && keys[0] === 'id') return false;
    var event = this.event;
    var validPhotos = [];
    var photo;
    var cat;
    
    // remove photos that have been removed from the event 
    if (attrs && attrs.photos && attrs.photos.length) {
      for (var i = 0; i < attrs.photos.length; i++) {
        photo = attrs.photos[i];
        cat = event.categories.get(photo.cat_id);
        if (photo.pid && cat && cat.photos && cat.photos.get(photo.pid)) {
          validPhotos.push(photo);
        }
      }
      attrs.photos = validPhotos;
    }
    return BaseModel.prototype.set.apply(this, arguments);
  },

  
  updateLock: function () { // rewrite the categories method 
    this.locked = false;
  },
  
  
  
  url: function () {
    var keychain = app.keychain.events.get(this.eid);
    var token = keychain ? keychain.token : '';
    
    var query = '?url='+ app.url +
        '&tok='+ token +
        (keychain && keychain.email ? 
        '&email='+ encodeURIComponent(keychain.email) : '') +
        (keychain && keychain.password ? 
        '&password='+ encodeURIComponent(keychain.password) : '');
        
    return app.apiUrl +'favorites'+ (this.isNew() ? '' : '/'+this.id) + query;
  },
  
});
