/*==========================================================================*\
  Language module
\*==========================================================================*/
"use strict";
// var sprintf = require('sprintf-js').sprintf;
var app = require('app');
var vsprintf = require('sprintf-js').vsprintf;
var storage = window.localStorage || {};
// var console = require('app/utils/console-mock');

var locales = {
  en: require('./en'),
  ru: require('./ru'),
};

var moment = require('moment');
// we need to mention all non-en moment locales for browserify to pick them up
require('moment/locale/ru');


module.exports = new (require('ampersand-model').extend({
  props: {
    id: 'string', // ID of the current locale
    locales: 'object', // all supported locales 
    locale: 'object', // shortcut to the current locale 
  },
  
  initialize: function () {
    this.locales = locales;
    
    var id = storage.locale || window.navigator.userLanguage || 
             window.navigator.language || 'en';
    id = id.substr(0, 2).toLowerCase();
    if (!locales[id]) id = 'en';
    
    this.listenTo(app, 'storage:locale', function (newId) {
      this.select(newId);
    });
    
    this.select(id, { silent: true });
  },
  
  // get a dictionary or sub-dictionary
  getDictionary: function (dictPath, localeId) {
    if (!localeId) localeId = this.id;
    var dict, i;
    if (dictPath) {
      dictPath = dictPath.split('.');
      i = 0;
      dict = this.locales[localeId].dictionary;
      while (dict && i < dictPath.length) {
        dict = dict[dictPath[i]];
        i++;
      }
    }
    
    if (!dict) dict = this.locales[localeId].dictionary.global;
    
    return dict;
  },
  
  
  // takes an english string with optional arguments and translates 
  // it to the current locale
  localize: function (dictionaryPath, str) {
    var args, i;
    // get all but the first two args without killing optimization
    if (arguments.length > 2) {
      args = new Array(arguments.length - 2);
      for (i = 0; i < args.length; i++) args[i] = arguments[i+2];
    }
    else args = [];
    
    if (args[0] && args[0]._isAMomentObject && !dictionaryPath) { // moment.js date
      return this.localizeDate(str, args[0]);
    }
    
    var dict = this.getDictionary(dictionaryPath); // dictionary to use
    
    // look in specified dictionary or global one 
    var item = dict[str] || this.locale.dictionary.global[str];
    
    if (!item) {
      // console.warn(this.id + (dictionaryPath ? '.'+ dictionaryPath : '') +
      //     ' dictionary doesn\'t have a translation for: '+ str);
      if (this.id !== 'en') { // fallback to english 
        dict = this.getDictionary(dictionaryPath, 'en');
      }
      item = dict[str] || this.locales.en.dictionary.global[str] || str;
    }
    
    // dictionary item should return a string for sprintf  
    var res = typeof item === 'function' ? item.apply(null, args) : item;
    
    return vsprintf(res, args);
  },
  
  localizeDate: function (format, moment) {
    if (moment.locale() !== this.id) moment.locale(this.id);
    return moment.format(format);
  },
  
  
  // Changes current locale and triggers 'select' event (if not silenced)
  select: function (id, options) {
    if (!this.locales[id]) console.warn('Requested language not found: '+ id);
    if (id === this.id || !this.locales[id]) return;
    
    this.id = id;
    this.locale = this.locales[this.id];
    moment.locale(id);
    storage.locale = id;
    if (!options || !options.silent) this.trigger('select');
  },
}))();
