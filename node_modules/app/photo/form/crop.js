/*============================================================================*\
  A Module managing cropping for a single print size
\*============================================================================*/
"use strict";

var BaseModel = require('app/base/base-model');

var app = require('app');

// var minDpi = 300; // minimum DPI for photo cropping 
// var minShrink = 10; // min available shrink % to allow resizing

module.exports = BaseModel.extend({
  props: {
    option: 'object', // purchase option view
    photo: 'object', // photo view 
    ratio: 'number', // print size width/height
    
    canRotate: ['boolean', true, false], // whether crop area can turn 90 deg
    rotated: ['boolean', true, false], // whether crop area is turned 90 deg
    
    left: ['number', true, 0], // distance from left in %
    right: ['number', true, 0], // distance from right in %
    top: ['number', true, 0], // distance from top in %
    bottom: ['number', true, 0], // distance from bottom in %
    
    changed: ['boolean', true, false], // whether crop was adjusted by user 
    
    // print size dimensions in current crop orientation 
    inchesWidth: ['number', true, 0],
    inchesHeight: ['number', true, 0],
    
    minWidth: ['number', true, 0], // minimum width in % of the original
    
    gesture: 'any', // info on currently handled gesture
    
    sizeStr: ['string', true, ''],
  },
  
  initialize: function (options) {
    this.option = options.option;
    this.photo = options.photo;
    
    var photoRatio = this.photo.model.ratio;
    var photoWidth = this.photo.model.width;
    var photoHeight = this.photo.model.height;
    
    this.ratio = this.option.model.size.width / this.option.model.size.height;
    
    // make sure print size is the same orientation as the photo 
    if (this.ratio > 1 && photoRatio < 1 || this.ratio < 1 && photoRatio > 1) {
      this.inchesWidth = this.option.model.size.height;
      this.inchesHeight = this.option.model.size.width;
    }
    else {
      this.inchesWidth = this.option.model.size.width;
      this.inchesHeight = this.option.model.size.height;
    }
    
    this.sizeStr = this.inchesWidth +'" x '+ this.inchesHeight +'"';
    
    // this.minWidth = minDpi * this.inchesWidth / photoWidth * 100;
    // if (this.minWidth > 100 - minShrink) this.minWidth = 100;
    
    // stick to fixed min size of 1/3 for now
    // this.minWidth = 58;
    if (this.ratio > photoRatio) {
      this.minWidth = 58;
    }
    else {
      this.minWidth = photoHeight * this.ratio / photoWidth * 58;
    }
    this.canRotate = true;
    
    // see if photo's size allows to rotate the crop area
    // this.canRotate = minDpi * this.inchesHeight / photoWidth * 100 < 90;
        // this.photo.model.width >= minDpi * this.inchesHeight;
    
    this.ratio = this.inchesWidth / this.inchesHeight;
    
    this.reset();
  },
  
  setValues: function (crop) {
    this.top = crop.top;
    this.right = crop.right;
    this.bottom = crop.bottom;
    this.left = crop.left;
    this.changed = true;
  },
  getValues: function () {
    return {
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      left: this.left,
    };
  },
  
  handleEvent: function (e) {
    if (!this.gesture) {
      app.router.lightbox.cursor = '';
      this.detachEvents();
      return;
    }
    switch (e.type) {
      case 'mousemove': case 'touchmove':
        if (e.touches && e.touches.length > 1) this.onPinch(e);
        if (this.gesture.type === 'drag') this.onDragMove(e);
        else this.onResizeMove(e);
        break;
      case 'mouseup': case 'touchend':
        if (this.gesture.type === 'drag') this.onDragUp(e);
        else this.onResizeUp(e);
        break;
    }
  },
  
  onButtonClick: function (e) {
    var classList = e.target.closest('.button').classList;
    if (classList.contains('reset')) {
      this.reset();
      this.photo.applyCrop(this);
    }
    else if (classList.contains('rotate')) { 
      this.rotate();
      this.photo.applyCrop(this);
    }
    else if (classList.contains('save')) this.save();
  },
  
  
  reset: function (options) {
    var photoWidth = this.photo.model.width;
    var photoHeight = this.photo.model.height;
    
    if (this.rotated || options && options.rotate) this.rotate();
    
    if (this.ratio > this.photo.model.ratio) {
      this.top = this.bottom = 
          (photoHeight - photoWidth / this.ratio) / photoHeight / 2 * 100;
      this.left = this.right = 0;
    }
    else {
      this.top = this.bottom = 0;
      this.left = this.right = 
          (photoWidth - photoHeight * this.ratio) / photoWidth / 2 * 100;
    }
    
    this.changed = false;
  },
  rotate: function () {
    if (!this.canRotate) return;
    var photoWidth = this.photo.model.width;
    var photoHeight = this.photo.model.height;
    
    var inchesWidth = this.inchesWidth;
    this.inchesWidth = this.inchesHeight;
    this.inchesHeight = inchesWidth;
    
    this.sizeStr = this.inchesWidth +'" x '+ this.inchesHeight +'"';
    
    this.ratio = this.inchesWidth / this.inchesHeight;
    var photoRatio = this.photo.model.ratio;
    
    // stick to fixed min size of ~ 2/3 for now
    if (this.ratio > photoRatio) {
      this.minWidth = 58;
    }
    else {
      this.minWidth = photoHeight * this.ratio / photoWidth * 58;
    }
    
    // this.minWidth = this.ratio > 1 ? 
    // this.minWidth = this.rotated ? 58 
    //     : 58 * Math.max(this.inchesWidth, this.inchesHeight) / 
    //            Math.min(this.inchesWidth, this.inchesHeight);
               
    // this.minWidth = minDpi * this.inchesWidth / photoWidth * 100;
    // if (this.minWidth > 100 - minShrink) this.minWidth = 100;
    
    var oldWidth = (100 - this.left - this.right) * photoWidth / 100;
    var oldHeight = (100 - this.top - this.bottom) * photoHeight / 100;
    var newWidth = oldHeight;
    var newHeight = oldWidth;
    
    // console.log('newWidth', newWidth);
    // if (newWidth / photoWidth < this.minWidth) {
    //   newWidth = this.minWidth * photoWidth;
    //   newHeight = newWidth / this.ratio * photoHeight;
    // }
    
    
    if (newWidth / photoWidth * 100 < this.minWidth) {
      newWidth = this.minWidth * photoWidth / 100;
      newHeight = newWidth / this.ratio;
    }
    
    if (newWidth > photoWidth) {
      newWidth = photoWidth;
      newHeight = newWidth / this.ratio;
    }
    else if (newHeight > photoHeight) {
      newHeight = photoHeight;
      newWidth = newHeight * this.ratio;
    }
    
    oldWidth = 100 - this.left - this.right;
    oldHeight = 100 - this.top - this.bottom;
    newWidth = newWidth / photoWidth * 100;
    newHeight = newHeight / photoHeight * 100;
    
    this.top = this.top - (newHeight - oldHeight) / 2;
    this.bottom = this.bottom - (newHeight - oldHeight) / 2;
    this.left = this.left - (newWidth - oldWidth) / 2;
    this.right = this.right - (newWidth - oldWidth) / 2;
    
    if (this.top < 0) { this.bottom += this.top; this.top = 0; }
    else if (this.bottom < 0) { this.top += this.bottom; this.bottom = 0; }
    if (this.left < 0) { this.right += this.left; this.left = 0; }
    else if (this.right < 0) { this.left += this.right; this.right = 0; }
    
    this.rotated = !this.rotated;
    this.changed = true;
    
    // this.scale(.99, 'top', 'left');
  },
  
  save: function () {
    this.option.toggleCropping();
  },
  
  /*==========================================================================*\
    Dragging crop area in any direction
  \*==========================================================================*/
  onDragStart: function (e) {
    if (e.preventDefault) e.preventDefault();
    
    var gt = this.gesture = {};
    
    gt.type = 'drag';
    gt.x0 = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
    gt.y0 = e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY;
    
    app.router.lightbox.cursor = 'move';
    this.attachEvents();
  },
  onDragMove: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (e.touches && e.touches.length > 1) return this.onPinch(e);
    
    var x = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
    var y = e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY;
    
    var gt = this.gesture;
    var dx = (x - gt.x0) / this.photo.imageWidth * 100;
    var dy = (y - gt.y0) / this.photo.imageHeight * 100;
    
    if (this.top + dy < 0) dy = -this.top;
    else if (this.bottom - dy < 0) dy = this.bottom;
    
    if (this.left + dx < 0) dx = -this.left;
    else if (this.right - dx < 0) dx = this.right;
    
    this.top += dy;
    this.bottom -= dy;
    this.left += dx;
    this.right -= dx;
    
    gt.x0 = x;
    gt.y0 = y;
    
    this.correctZeros();
    
    this.photo.applyCrop(this);
    
    this.changed = true;
  },
  onDragUp: function () {
    app.router.lightbox.cursor = '';
    this.gesture = null;
    this.detachEvents();
  },
  
  /*==========================================================================*\
    Resizing Crop Area
  \*==========================================================================*/
  onPinch: function (e) {
    if (e.preventDefault) e.preventDefault();
    var x = e.touches[0].clientX;
    var y = e.touches[0].clientY;
    var x1 = e.touches[1].clientX;
    var y1 = e.touches[1].clientY;
    var distance = Math.sqrt((x1-x)*(x1-x) + (y1-y)*(y1-y));
    
    var gt = this.gesture;
    if (!gt.pinchDistance) {
      gt.pinchDistance = distance;
      return;
    }
    
    this.scale(Math.sqrt(distance / gt.pinchDistance));
    gt.pinchDistance = distance;
    this.photo.applyCrop();
    this.changed = true;
  },
  
  onResizeStart: function (e) {
    if (e.preventDefault) e.preventDefault();
    var x = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
    var y = e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY;
    
    // app.view.el.classList.add('cursor-nwse-resize');
    
    var gt = this.gesture = {};
    var rect = e.target.getBoundingClientRect();
    
    gt.type = 'resize';
    gt.x0 = x;
    gt.y0 = y;
    
    var className = e.target.className;
    var leftSide = className.indexOf('left') > -1;
    var topSide = className.indexOf('top') > -1;
    
    gt.xSide = leftSide ? 'left' : 'right';
    gt.xStatic = leftSide ? this.right : this.left;
    gt.xSign = leftSide ? 1 : -1;
    
    gt.ySide = topSide ? 'top': 'bottom';
    gt.yStatic = topSide ? this.right : this.left;
    gt.ySign = topSide ? 1 : -1;
    
    
    gt.xStart = this[gt.xSide];
    gt.yStart = this[gt.ySide];
    
    gt.photoRect = this.photo.img.getBoundingClientRect();
    
    // offset to the center of the resize handle 
    gt.offsetX = rect.left + 22 - x;
    gt.offsetY = rect.top + 22 - y;
    
    // gt.startTop = this.top;
    // gt.startRight = this.right;
    // gt.startBottom = this.bottom;
    // gt.startLeft = this.left;
    
    if (leftSide && topSide || !leftSide && !topSide) {
      app.router.lightbox.cursor = 'nwse-resize';
    }
    else if (leftSide && !topSide || !leftSide && topSide) {
      app.router.lightbox.cursor = 'nesw-resize';
    }
    this.attachEvents();
  },
  onResizeMove: function (e) {
    if (e.preventDefault) e.preventDefault();
    var x = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
    var y = e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY;
    
    var gt = this.gesture;
    var width, height;
    
    var rect = this.getRect(gt.photoRect);
    var newPos;
    var clientX = x + gt.offsetX;
    var clientY = y + gt.offsetY;
    if (clientX < gt.photoRect.left) clientX = gt.photoRect.left;
    if (clientX > gt.photoRect.width + gt.photoRect.left) {
      clientX = gt.photoRect.width + gt.photoRect.left;
    }
    
    if (clientY < gt.photoRect.top) clientY = gt.photoRect.top;
    if (clientY > gt.photoRect.height + gt.photoRect.top) {
      clientY = gt.photoRect.height + gt.photoRect.top;
    }
    
    var xPos = (rect[gt.xSide] - clientX) * gt.xSign;
    var yPos = (rect[gt.ySide] - clientY) * gt.ySign;
    
    if (xPos > yPos) { // resize on x axis
      newPos = Math.abs(clientX - gt.photoRect[gt.xSide]) /
               this.photo.imageWidth * 100;
      
      width = (100 - gt.xStatic - newPos);
      this.scale(width / (100 - gt.xStatic - this[gt.xSide]), 
                 gt.xSide, gt.ySide);
    }
    else {
      newPos = Math.abs(clientY - gt.photoRect[gt.ySide]) /
               this.photo.imageHeight * 100;
               
      height = (100 - gt.yStatic - newPos);     
      this.scale(height / (100 - gt.yStatic - this[gt.ySide]), 
                 gt.xSide, gt.ySide);
    }
    
    // width = (100 - this.left - this.right) * this.photo.imageWidth;
    // height = (100 - this.top - this.bottom) * this.photo.imageHeight;
    
    this.photo.applyCrop(this);
    
    this.changed = true;
  },
  onResizeUp: function () {
    app.router.lightbox.cursor = '';
    this.gesture = null;
    this.detachEvents();
  },
  
  // get cropped rect's top/right/bottom/left coordinates
  getRect: function (photoRect) {
    // if (!photoRect) photoRect = this.photo.img.getBoundingClientRect();
    var photo = this.photo;
    return {
      top: photoRect.top + photo.imageHeight * this.top / 100,
      right: photoRect.left + photo.imageWidth - 
             photo.imageWidth * this.right / 100,
      bottom: photoRect.top + photo.imageHeight - 
              photo.imageHeight * this.bottom / 100,
      left: photoRect.left + photo.imageWidth * this.left / 100,
    };
  },
  
  attachEvents: function () {
    document.body.addEventListener('mousemove', this, false);
    document.body.addEventListener('mouseup', this, false);
    document.body.addEventListener('touchmove', this, false);
    document.body.addEventListener('touchend', this, false);
  },
  detachEvents: function () {
    document.body.removeEventListener('mousemove', this, false);
    document.body.removeEventListener('mouseup', this, false);
    document.body.removeEventListener('touchmove', this, false);
    document.body.removeEventListener('touchend', this, false);
  },
  
  correctZeros: function () { // replaces very small values with zeros
    if (this.left < 0.02) {
      this.right += this.left;
      this.left = 0;
    }
    if (this.right < 0.02) {
      this.left += this.right;
      this.right = 0;
    }
    if (this.top < 0.02) {
      this.bottom += this.top;
      this.top = 0;
    }
    if (this.bottom < 0.02) {
      this.top += this.bottom;
      this.bottom = 0;
    }
  },
  
  getLargestOverflow: function (crop) {
    var model = this.photo.model;
    var overflow = {
      amount: 0,
      side: null
    };
    var amount;
    
    for (var i in crop) {
      if (crop[i] >= 0) continue;
      amount = i === 'left' || i === 'right' 
          ? -crop[i] * model.width 
          : -crop[i] * model.height;
      if (amount > overflow.amount && -crop[i] > 0.001) {
        overflow.amount = amount;
        overflow.side = i;
      }
    }
    if (overflow.amount) overflow.amount = -crop[overflow.side];
    return overflow;
  },
  
  scale: function (f, xSide, ySide, correction) {
    if (!f) return;
    var newCrop = {
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      left: this.left,
    };
    var model = this.photo.model;
    var oldWidth = 100 - this.left - this.right;
    var oldHeight = 100 - this.top - this.bottom;
    
    var width = oldWidth * f;
    if (width < this.minWidth) width = this.minWidth;
    
    if (f > 1) {
      if (!xSide && this.left < 0.01) xSide = 'right';
      else if (!xSide && this.right < 0.01) xSide = 'left';
      if (!ySide && this.top < 0.01) ySide = 'bottom';
      else if (!ySide && this.bottom < 0.01) ySide = 'top';
    }
    
    var height = (width * model.width / this.ratio) / model.height;
    
    if (xSide) newCrop[xSide] += oldWidth - width;
    else {
      newCrop.left += (oldWidth - width) / 2;
      newCrop.right += (oldWidth - width) / 2;
    }
    if (ySide) newCrop[ySide] += oldHeight - height;
    else {
      newCrop.top += (oldHeight - height) / 2;
      newCrop.bottom += (oldHeight - height) / 2;
    }
    
    
    var overflow = this.getLargestOverflow(newCrop);
    var scaleBack;
    if (overflow.amount && !correction) {
      scaleBack = 1 + (f-1) * 
          this[overflow.side] / (this[overflow.side] + overflow.amount);
      this.scale(scaleBack, xSide, ySide, true);
    }
    else {
      for (var i in newCrop) this[i] = newCrop[i];
    }
  
    this.correctZeros();
    
      
    if (scaleBack) {
      // this.scale(scaleBack, xSide, ySide);
    }
  },
});
