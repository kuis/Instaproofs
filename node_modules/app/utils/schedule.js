/*==========================================================================*\
  rAF-based scheduler for task throttling
  var id = schedule(fn, priority);
  schedule.unschedule(id); // remove the task if you changed your mind
  
  'high' priority tasks all run before the next frame.
  Others only run one per frame.
\*==========================================================================*/
"use strict";

var ua = require('app/utils/ua');
var loop = null; // rAF ID
var taskID = 1; // ID counter for new tasks
var queue = { low: [], normal: [], high: [], highest: [] };
var index = {}; // index of scheduled runs by IDs for quicker removal

var instantPriorities = ['highest', 'high'];
var deferredPriorities = ['normal', 'low']; // tasks running one per frame

function run() {
  var i, n, task;
  
  // console.log('schedule queue', queue.highest.length, queue.high.length, 
  //             queue.normal.length, queue.low.length);
  
  // high priority tasks run first and all at once 
  for (n = 0; n < instantPriorities.length; n++) {
    for (i = 0; i < queue[instantPriorities[n]].length; i++) {
      task = queue[instantPriorities[n]][i];
      // console.log(instantPriorities[n] +' priority task '+ task.id);
      delete index[task.id];
      if (task.fn) task.fn.call(task.context);
    }
    queue[instantPriorities[n]] = [];
  }
  
  
  // Run through all other queues, removing all items as 
  // we go through but stop after one with 'fn' is encountered.
  // Ones without 'fn' are tasks marked as removed 
  // so we simply shift through them
  priorities_loop: for (i = 0; i < deferredPriorities.length; i++) {
    task = null;
    while (!task || !task.fn) {
      task = queue[deferredPriorities[i]].shift();
      if (task && task.fn) {
        // console.log(deferredPriorities[i] +' priority task '+ task.id);
        delete index[task.id];
        task.fn.call(task.context);
        break priorities_loop;
      }
      if (!task) break;
    }
  }
  
  loop = queue.highest.length || queue.high.length || queue.normal.length 
        || queue.low.length ? ua.raf(run) : null;
}


module.exports = function (fn, priority, context) {
  if (!loop) loop = ua.raf(run);
  var id = taskID++;
  index[id] = queue[priority || 'normal'].push({
    fn: fn,
    id: id,
    context: context || null,
  });
  // console.log('schedule', priority || 'normal', id);
  return id;
};


// unschedule previously scheduled tasks by ID or an array of IDs ============
module.exports.unschedule = function (IDs) {
  if (!IDs) return;
  if (typeof IDs !== 'object') IDs = [IDs];
  for (var i = 0, len = IDs.length; i < len; i++) {
    // remove reference to task's function so that it can be GC-ed.
    // We don't touch the actual queues here as the main runner
    // will remove these empty tasks more efficiently without splicing
    if (index[IDs[i]]) {
      delete index[IDs[i]].fn;
      delete index[IDs[i]].context;
      delete index[IDs[i]];
    }
  }
};
