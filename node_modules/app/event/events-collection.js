"use strict";

var BaseCollection = require('app/base/base-collection');
var EventModel = require('app/event/event-model');

var app = require('app');
var ua = require('app/util/ua/ua');
var schedule = require('app/util/schedule/schedule');

module.exports = BaseCollection.extend({
  model: EventModel,
  // url: '/api/events',
  url: app.apiUrl +'events',
  // url: 'https://secure.instaproofs.com/api/rest2/',
  sortedBy: 'date',
  filteredBy: 'all',
  searchQuery: '',
  page: 0,
  perPage: 15,
  cache: {},
  complete: true,
  pendingNewItems: null, // schedule ID for throttled items parsing
  request: null, // XHR currently in progress 
  
  initialize: function (models, ops) {
    this.newItems = []; // new items scheduled for throttled addition
    
    if (models && typeof models === 'object' && 
        (typeof models.filter === 'string' || typeof models.sort === 'string')){
      console.log(models);
      console.error('wrong arguments');
    }
    
    ops = ops || {};
    if (ops.filter) this.filteredBy = ops.filter;
    if (ops.sort) this.sortedBy = ops.sort; 
    this.comparator = this.comparators[this.sortedBy];
    this.cache = {};
  },
  
  addNewItems: function () {
    this.pendingNewItems = null;
    var i = 0, id;
    while (this.newItems.length && i < 2) {
      id = this.newItems[0].id;
      if (app.eventModels[id]) {
        this.add(app.eventModels[id], { sort: false });
      }
      else {
        this.add(this.newItems[0], { sort: false });
        app.eventModels[id] = this.models[this.models.length-1];
        i++;
      }
      this.newItems.shift();
    }
    if (this.newItems.length) {
      this.pendingNewItems = schedule(this.addNewItems, 'normal', this);
    }
    else {
      this.request = null;
      this.trigger('more');
      this.trigger('sync', this);
      // console.log('Parsing items took: '+ (ua.now() - this.newItems.time));
    }
  },

  updateSelector: function (ops) {
    if (!ops.backFromSearch) {
      this.filteredBy = ops.filter;
      this.sortedBy = ops.sort;
    }
    else {
      this.searchQuery = '';
    }
    this.comparator = this.comparators[this.sortedBy];
    this.page = 0;
    if (this.cache[this.filteredBy + this.sortedBy]) {
      this.reset(this.cache[this.filteredBy+this.sortedBy].data);
      this.setComplete(this.cache[this.filteredBy+this.sortedBy].complete);
    }
    else this.fetch({ reset: true });
  },
  searchFor: function (str) {
    this.page = 0;
    this.searchQuery = str;
    this.comparator = null;
    this.fetch({ reset: true });
  },
  
  loadMore: function () {
    if (this.request) return;
    this.page++;
    this.fetch({ add: true, remove: false, reset: false });
  },
  
  setComplete: function (complete) {
    if (this.complete !== complete) {
      this.trigger(complete ? 'complete' : 'incomplete');
    }
    this.complete = !!complete;
  },
  
  fetch: function (options) {
    console.trace('fetch');
    var self = this;
    options = options || {};
    var data = options.data = options.data || {};

    this.stopListening(app, 'online');
    
    data.limit = this.perPage;
    data.offset = this.page * this.perPage;
    
    if (!this.searchQuery) {
      data.sort = this.sortedBy;
      data.filter = this.filteredBy;
    }
    else {
      data.search = this.searchQuery;
      // options.reset = false;
    }
    
    // data.url = "http://demotest.instaproofs.com";
    // data.url = "http://demo.instaproofs.com";
    data.url = app.url;
    // data.key = "IoY9NqmfciX8nZVWrTxl5m3sjpwUe6IA";
    // data.q = 'bootstrap';
    
    if (this.request) this.request.abort();
    
    this.trigger(options.reset ? 'reloading' : 'loading');
    
    
    // fetching a list from scratch ==========================================
    if (options.reset) {
      options.success = function (col, resp) {
        console.log('success');
        if (!data.search) self.cache[data.filter + data.sort] = resp;
        self.request = null;
      };
      options.error = function () {
        console.log('fetching error', arguments);
        self.request = null;
        app.state.setOffline();
        self.listenToOnce(app, 'online', function () {
          self.fetch(options);
        });
      };
      return this.request = BaseCollection.prototype.fetch.call(this, options);
    }
    
    
    // fetching additional batches ========================================== 
    options.success = function(res) {
      console.log('success');
      self.setComplete(!!res.complete);
      self.newItems = self.newItems.concat(res.data);
      self.newItems.time = ua.now(); 
      if (!self.pendingNewItems) {
        self.pendingNewItems = schedule(self.addNewItems, 'normal', self);
      }
      // self.trigger('sync', self, res, options);
    };
    
    options.error = function(resp) {
      console.log('fetching error', arguments);
      self.request = null;
      app.state.setOffline();
      self.listenToOnce(app, 'online', function () {
        self.fetch(options);
      });
      self.trigger('error', self, resp, options);
    };
    return this.request = this.sync('read', this, options);
  },

  onFetchError: function () {

  },
  
  parse: function (res) {
    this.setComplete(!!res.complete);
    return BaseCollection.prototype.parse.call(this, res);
  },
  
  
  // sorting comparators =====================================================
  comparators: {
    date: function (a, b) {
      // return 0;
      return b.date - a.date;
    },
    name: function (a, b) {
      // return 0;
      var aName = a.name.toUpperCase();
      var bName = b.name.toUpperCase();
      // if (aName === bName) return b.date - a.date;
      if (aName === bName) return 0;
      if (aName > bName) return 1;
      if (aName < bName) return -1;
      return 0;
    },
    type: function (a, b) {
      // return 0;
      var aType = a.type.toUpperCase();
      var bType = b.type.toUpperCase();
      if (aType === bType && a.date && b.date) {
        return b.date.valueOf() - a.date.valueOf();
      }
      else {
        if (aType > bType) return 1;
        if (aType < bType) return -1;
        return 0;
      }
    },
  },
});
