/*==========================================================================*\
  Event Model
\*==========================================================================*/
"use strict";

var app = require('app');
var BaseModel = require('app/base/base-model');
var Cart = require('app/cart/cart-model');
var Favorites = require('app/favorites/favorites-model');
var Hides = require('app/hides/hides-model');
var CategoriesCollection = require('app/category/categories-collection');
var Discounts = require('app/sale/event-sales-model');
var ProductsCollection = require('app/product/products-collection');
var uid = 1;

var helpers = require('app/util/helpers/helpers');

module.exports = BaseModel.extend({
  isEventModel: true,
  
  extraProperties: 'ignore',
  // urlRoot: '/api/events',
  urlRoot: app.apiUrl +'events/',
  url: function () {
    var keychain = app.keychain.events.get(this.id);
    var optIn = (keychain && keychain.optIn) ? 1 : 0;
    return app.apiUrl +'events/'+ this.id + '?url='+ app.url +
           (keychain && keychain.email ? 
              '&email='+ encodeURIComponent(keychain.email) +
              '&opt_in='+ encodeURIComponent(optIn) : '') + 
           (keychain && keychain.password ? 
              '&password='+ encodeURIComponent(keychain.password) : '');
           // '&email=adam@instaproofs.com'+
           // '&password=contest2015';
  },
  props: {
    id: 'number',
    name: ['string', true, ''], // The name of the event
    description: ['string', true, ''], // Event's description
    img_url: ['string', true, ''], // URL for event's title image
    
    // left top|center top|center center etc.
    img_position: ['string', true, ''], 
    
    allow_pickup: ['boolean', true, false], // allow 'Pickup at Studio' shipping
    pickup_text: ['string', true, ''],
    date: ['moment', true, null], // The date of the event
    exp_date: ['moment', true, null], // The expiration date for the event
    city: ['string', true, ''], // The city where the event was held
    state: ['string', true, ''], // state/province/county where the event was 
    // country: ['string', true, ''], // The country where the event was held
    country: 'any', // The country where the event was held
    
    min_purchase: ['number', true, 0],
    
    music: ['array', false], // list of music tracks 
    
    // The type of event (Wedding, Dance, Fashion, Engagement, etc.)
    type: ['string', true, ''],
    type_id: ['number', true, 0], // The event type's ID
    
    password: ['boolean', true, false], // password protected or not
    password_hint: ['string', true, ''],
    email: ['boolean', true, false], // requries an email address to enter it
    show: ['boolean', true, false], // whether the event should be listed
    
    // whether the event's image should be displayed 
    // in the event list and login page
    display_image: ['boolean', true, false], 
    
    // Custom value representing a single event.  
    // Used like this: http://proofs.mysite.com/eventAlias  
    alias: ['string', true, ''], 
    
    showcase: ['boolean', true, false], // a "Showcased" event
    
    addons: 'array',
    
    products: 'array',
  },
  collections: {
    categories: CategoriesCollection, // list of categories 
    products_list: ProductsCollection, // list of products
  },
  
  children: {
    // sales: require('app/sale/event-sales-model'),
  },
  
  session: {
    complete: ['boolean', true, false], // all event's data has been fetched 
    fetching: 'boolean', // whether we're currently fetching the event's data 
    sales: 'state',
  },
  
  derived: {
    allowedHide: {
      cache: false,
      fn: function () {
        var keychain = app.keychain.events.get(this.id);
        return (keychain && keychain.allowedHide) ? true : false;
      },
    },
    allowedDownload: {
      cache: false,
      fn: function () {
        var keychain = app.keychain.events.get(this.id);
        return (!keychain || keychain.allowedDownload) ? true : false;
      },
    },
    allowedFullDownload: {
      cache: false,
      fn: function () {
        var keychain = app.keychain.events.get(this.id);
        return (keychain && keychain.allowedFullDownload) ? true : false;
      },
    },
    
    cart: { // user's cart for this event 
      fn: function () {
        if (!app.eventCarts[this.id]) {
          app.eventCarts[this.id] = new Cart({
            eid: this.id,
          }, {
            event: this,
          });
        }
        return app.eventCarts[this.id];
      },
    },
    
    // sales: {
    //   fn: function () {
    //     return new Discounts({
    //       // eid: this.id,
    //     });
    //   },
    // },
    
    favorites: { // user's cart for this event 
      fn: function () {
        if (!app.favorites[this.id]) {
          app.favorites[this.id] = new Favorites({
            eid: this.id,
            event: this,
          });
        }
        return app.favorites[this.id];
      },
    },
    hides: { // user's cart for this event 
      fn: function () {
        if (!app.hides[this.id]) {
          app.hides[this.id] = new Hides({
            eid: this.id,
            event: this,
          });
        }
        return app.hides[this.id];
      },
    },
    
    app_url: {
      fn: function () {
        return '#events/' + this.id;
      }
    },

    thumb_url: {
      deps: ['img_url', 'display_image'],
      fn: function () {
        if (!this.img_url) return '';
        var width = 595;
        if (window.screen && window.screen.width < 610) {
          width = window.screen.width - 15;
        }
        var url = helpers.toThumbUrl(this.img_url, width);
        return this.display_image ? url : helpers.toBlurUrl(url);
      },
    },
    thumb_blur_url: {
      deps: ['thumb_url'],
      fn: function () {
        return helpers.toBlurUrl(this.thumb_url);
      },
    },
    
    locked: {
      deps: ['password', 'email', 'complete'],
      cache: false,
      fn: function () {
        if (!this.email && !this.password) return false;
        var keychain = app.keychain.events.get(this.id);
        if (!keychain || !keychain.verified) return true;
        if (this.email && !keychain.email) return true;
        if (this.password && !keychain.password) return true;
        return false;
      },
    },
    
    // complete: {
    //   deps: ['categories'],
    //   fn: function () {
    //     var firstCategory = this.categories && this.categories.at(0);
    //     return !!(firstCategory && firstCategory.photos.length);
    //   },
    //   cache: false,
    // },
  },
  
  fetch: function (options) {
    if (this.fetching) return;
    options = options || {};
    var success = options.success;
    var error = options.error;
    
    options.success = function (model, res, options) {
      if (res.status !== 200) {
        if(res.status === 404) {
          //The event couldn't be located. Go to the home page.
          console.log("Could not locate the event.");
          app.navigate('home');
          window.location.reload();
        }
        else if (res.status === 401) {
          app.keychain.removeEventKeys(model.id);
          if (app.state.bootstrapped) app.view.splashView.showLoginForm(model);
        }
      }
      else {
        app.keychain.confirmKeys(model.id, res.permissions);
        
        // this.locked; // update `locked` so `change` is triggered 
        if (app.view.splashView.model === model) {
          app.view.splashView.hide();
        }
      }
      if (success) success.call(model, model, res, options);
    };
    options.error = function (model, res, options) {
      console.log('event fetch error');
      if (error) error.call(model, model, res, options);
      if (model.locked) app.router.login(model);
      else {
        model.fetch();
      }
    };
    
    
    // read data from storage cache if it's fresh
    // var now = Date.now();
    // var storedTime = app.storage['eventStorageTime'+ this.id];
    // if (storedTime && storedTime >= now - 10 * 24 * 60 * 60000) {
    //   var data = app.storage['eventData'+ this.id];
    //   if (!data) return BaseModel.prototype.fetch.call(this, options);
    //   data = JSON.parse(data);
    //   data = this.parse(data);
    //   if (!this.set(this.parse(data, options), options)) {
    //     return BaseModel.prototype.fetch.call(this, options);
    //   }
    //   this.trigger('sync', this, data, options);
    //   return;
    // }
    
    return this.fetchByOrigin(options);
  },

  fetchByOrigin: function (options) {
    if (this.fetching) return;

    return BaseModel.prototype.fetch.call(this, options);
  },
  
  initialize: function () {
    this.sales = new Discounts();
    this.listenTo(this, 'request', function () {
      this.fetching = true;
    });
    this.listenTo(this, 'sync error', function () {
      this.fetching = false;
    });
    this.listenTo(app.keychain, 'change:mtime', function () {
      return this.locked; // update locked value
    });
    
    this.listenTo(this, 'change:complete', function () {
      if (this.products_list.length) return;
      var products = [];
      for (var i = 0; i < this.products.length; i++) {
        products.push(app.products.get(this.products[i]));
      }
      this.products_list = new ProductsCollection(products);
    });
    
    this.listenTo(app, 'storage:buyPreset'+this.id, this.readPresetFromStorage);
    var stored = app.storage['buyPreset'+this.id];
    if (stored) {
      this.readPresetFromStorage(stored);
    }
  },
  
  readPresetFromStorage: function (newData) {
    newData = JSON.parse(newData);
    if (newData) {
      app.buyPresets[this.id] = newData;
    }
  },
  
  parse: function (res) {
    var self = this;
    var i, j, option;
    var data = (res.id && !res.data) ? res : res.data;
    var status = res.status;
    if (status === 401) {
      app.trigger('event-401');
    }
    // if (res.status && res.status !== 200) {
    if (!data.id) {
      return BaseModel.prototype.parse.apply(this, [data]);
    }
    
    
    if (!data.discounts) data.discounts = {
      general: [],
      size_override: [],
    };
    var discounts = data.discounts;
    if (!Array.isArray(discounts.general)) {
      discounts.general = discounts.general ? [discounts.general] : [];
    }
    if (!Array.isArray(discounts.size_override)) {
      discounts.size_override = discounts.size_override ? 
                                    [discounts.size_override] : [];
    }
    
    if (data.discounts) {
      if (!this.sales) {
        this.sales = new Discounts();
      }
      this.sales.setData(data.discounts);
    }
    delete data.discounts;
    
    if (res.cart && res.cart.id) {
      this.cart;
      res.cart.mtime = Date.now();
      if (res.cart.photos) for (i = 0; i < res.cart.photos.length; i++) {
        for (j = 0; j < res.cart.photos[i].options.length; j++) {
          option = res.cart.photos[i].options[j];
          if ('top' in option.crop) {
            option.crop.changed = true;
          }
        }
      }
      this.cart.set(res.cart);
    }
    if (res.favorites && res.favorites.id) {
      this.set('categories', data.categories); // favs need photos 
      res.favorites.mtime = Date.now();
      this.favorites.set(res.favorites, { parse: true });
    }
    if (res.hides && res.hides.id) {
      this.hides.set(res.hides);
    }
    
    var cat;
    if (!data.categories) {
      console.log('no cat', data);
      console.trace();
    }
   
    var fullData = ('addons' in data) && status === 200;
    if (fullData) {
      var hidden = res.hidden_images ? res.hidden_images.photos : [];
      this.hides.photos.set(hidden);
      
      if (app.state.bootstrapped) {
        // console.log('loaded event, bootstrap is there');
        setTimeout(function () {
          self.complete = true;
        }, 1);
      }
      else {
        // console.log('loaded event, waiting for bootstrap');
        app.state.on('change:bootstrapped', function () {
          var products = [];
          for (var i = 0; i < self.products.length; i++) {
            products.push(app.products.get(self.products[i]));
          }
          self.products_list = new ProductsCollection(products);
          setTimeout(function () {
            self.complete = true;
          }, 1);
        });
      }
    }
    return BaseModel.prototype.parse.apply(this, arguments);
  },
});
