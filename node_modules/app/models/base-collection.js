/*==========================================================================*\
  Base collection to be extended by all others
\*==========================================================================*/
"use strict";

var isArray = Array.isArray;
var extend = require('extend-object');

var app = require('app');
var Collection = require('ampersand-rest-collection');

// module.exports = require('ampersand-rest-collection');
module.exports = Collection.extend({
  set: function (models, options) {
    options = extend({add: true, remove: true, merge: true}, options);
    if (options.parse) models = this.parse(models, options);
    var singular = !isArray(models);
    models = singular ? (models ? [models] : []) : models.slice();
    var id, model, attrs, existing, sort, i, length;
    var at = options.at;
    var sortable = this.comparator && (at == null) && options.sort !== false;
    var sortAttr = ('string' === typeof this.comparator) ? this.comparator 
                                                         : null;
    var toAdd = [], toRemove = [], modelMap = {};
    var add = options.add, merge = options.merge, remove = options.remove;
    var order = !sortable && add && remove ? [] : false;
    var targetProto = this.model && this.model.prototype || Object.prototype;

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (i = 0, length = models.length; i < length; i++) {
      attrs = models[i] || {};
      if (this.isModel(attrs)) {
        id = model = attrs;
      } else if (targetProto.generateId) {
        id = targetProto.generateId(attrs);
      } else {
        id = attrs[targetProto.idAttribute || this.mainIndex];
      }

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(id)) {
        if (remove) modelMap[existing.cid || existing[this.mainIndex]] = true;
        if (merge) {
          attrs = attrs === model ? model.attributes : attrs;
          if (options.parse) attrs = existing.parse(attrs, options);
          // if this is model
          if (existing.set) {
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          } else {
            // if not just update the properties
            extend(existing, attrs);
          }
        }
        models[i] = existing;

      // If this is a new, valid model, push it to the `toAdd` list.
      } else if (add) {
        model = models[i] = this._prepareModel(attrs, options);
        if (!model) continue;
        
        // CUSTOM: mind the order 
        toAdd.push({ model: model, at: models.length + i });
        this._addReference(model, options);
      }

      // Do not add multiple models with the same `id`.
      model = existing || model;
      if (!model) continue;
      if (order && 
          (
            (model.isNew && model.isNew() || !model[this.mainIndex]) || 
            !modelMap[model.cid || model[this.mainIndex]]
          )) {
        order.push({ model: model, at: null });
      }
      modelMap[model[this.mainIndex]] = true;
    }

    // Remove nonexistent models if appropriate.
    if (remove) {
      for (i = 0, length = this.length; i < length; i++) {
        model = this.models[i];
        if (!modelMap[model.cid || model[this.mainIndex]]) toRemove.push(model);
      }
      if (toRemove.length) this.remove(toRemove, options);
    }

    // See if sorting is needed, update `length` and splice in new models.
    if (toAdd.length || (order && order.length)) {
      if (sortable) sort = true;
      if (at != null) {
        for (i = 0, length = toAdd.length; i < length; i++) {
          this.models.splice(at + i, 0, toAdd[i].model);
        }
      } else {
        // var orderedModels = order || toAdd;
        var orderedModels = toAdd || order;
        for (i = 0, length = orderedModels.length; i < length; i++) {
          // CUSTOM: mind the order
          if (orderedModels[i].at === null || 
              this.models.length <= orderedModels[i].at) {
            this.models.push(orderedModels[i].model);
          }
          else {
            this.models.splice(orderedModels[i].at, 0, orderedModels[i].model);
          }
        }
      }
    }
    
    // Silently sort the collection if appropriate.
    if (sort) this.sort({silent: true});

    // Unless silenced, it's time to fire all appropriate add/sort events.
    if (!options.silent) {
      for (i = 0, length = toAdd.length; i < length; i++) {
        model = toAdd[i].model;
        if (model.trigger) {
          model.trigger('add', model, this, options);
        } else {
          this.trigger('add', model, this, options);
        }
      }
      if (sort || (order && order.length)) this.trigger('sort', this, options);
    }

    // Return the added (or merged) model (or models).
    return singular ? models[0] : models;
  },
  
  parse: function (res) {
    if (res && res.data && typeof res.data === 'object') {
      return res.data;
    }
    return res;
  },
  
  
  // parse: function (res) {
  //   if (res.config) {
  //     app.state.bootstrapped = true;
  //     app.config.set(res.config);
  //   }
  //   if (res.photographer) app.photographer.set(res.photographer);
  //   if (res.purchase_addons) app.purchaseAddons.set(res.purchase_addons);
  //   if (res.purchase_options) app.purchaseOptions.set(res.purchase_options, { 
  //     parse: true 
  //   });
  //   return res.data;
  // },
  
  // fetch: function (options) {
  //   options = options || {};
  //   options.data = options.data || {};
  //   if (!app.state.bootstrapped) {
  //     options.data.bootstrap = 1;
  //   }
  //   return Collection.prototype.fetch.call(this, options);
  // },
});
