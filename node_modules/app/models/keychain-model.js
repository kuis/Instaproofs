/*==========================================================================*\
  Keychain model storing all the user's login data 
\*==========================================================================*/
"use strict";

var app = require('app');
var _ =  require('underscore');

var EventKeysModel = require('./base-model').extend({
  props: {
    id: 'number',
    email: 'any',
    password: 'any',
    verified: ['boolean', true, false],
  },
});

var EventsCollection = require('./base-collection').extend({
  model: EventKeysModel,
});

module.exports = require('app/models/base-model').extend({
  // extraProperties: 'ignore',
  props: {
    mtime: 'number',
  },
  
  collections: {
    events: EventsCollection,
  },
  
  derived: {
    
  },
  
  initialize: function () {
    this.store = _.throttle(this.store, 300);
    var stored = app.storage.keychain;
    if (stored) this.set(JSON.parse(stored));
    // this.events.reset();
    this.listenTo(app, 'storage:keychain', this.storageCallback);
  },
  
  clear: function (currentId) { // logout from all events except currently open
    var currentEventId = currentId;
    // var currentEventId = currentId || 
    //     (app.currentPage && app.currentPage.eventId);
    if (!currentEventId) this.events.reset();
    else { // remove all but the current 
      var event;
      var remove = [];
      for (var i = 0; i < this.events.length; i++) {
        event = this.events.at(i);
        if (event.id !== currentEventId) remove.push(event.id);
      }
      if (remove.length) this.events.remove(remove);
      else return;
    }
    this.mtime = Date.now();
    this.store();
  },
  
  storageCallback: function (newData) {
    newData = JSON.parse(newData);
    if (!newData.mtime) return;
    console.log('storage callback', newData.mtime, this.mtime);
    if (newData.mtime > this.mtime) {
      this.set(newData);
      if (app.currentPage && app.currentPage.eventId) {
        var event = app.eventModels[app.currentPage.eventId];
        var keychain = this.events.get(event.id);
        if (event.name && event.locked) {
          if (!keychain || !keychain.verified || (event.email && !keychain.email) || 
              (event.password && !keychain.password) ) {
            app.navigate('home');
          }
        }
      }
    }
  },
  
  confirmKeys: function (id) {
    var model = this.events.get(id);
    if (!model) return;
    var changed = !model.verified;
    model.verified = true;
    if (changed) {
      this.mtime = Date.now();
      this.store();
    }
  },
  saveEventKeys: function (event, email, password, verified) {
    var model = this.events.get(event.id);
    verified = !!verified;
    var changed = false;
    if (!model) {
      changed = true;
      this.events.add({
        id: event.id,
        email: email,
        password: password,
        verified: verified,
      });
    }
    else {
      changed = model.email !== email || model.password !== password ||
                model.verified !== verified;
      model.set({
        email: email,
        password: password,
        verified: verified,
      });
    }
    if (changed) {
      this.mtime = Date.now();
      this.store();
    }
  },
  removeEventKeys: function (eid) {
    if (!this.events.get(eid)) return;
    this.events.remove(eid);
    this.mtime = Date.now();
    this.store();
  },
  
  store: function () {
    console.log('storing keychaing');
    app.storage.keychain = JSON.stringify(this.serialize());
  },
});
