/*==========================================================================*\
  Base view to be extended by all others
\*==========================================================================*/
"use strict";

var app = require('app');
var ua = require('app/util/ua/ua');
var helpers = require('app/util/helpers/helpers');
var lodashEscape = require('lodash.escape');
var schedule = require('app/util/schedule/schedule');

module.exports = require('ampersand-view').extend({
  // extraProperties: 'allow',
  props: {
    // list of data used for localizable chunks of content 
    lzData: { type: 'object', default: function () { return {}; }},
    lzId: ['number', true, 0],
  },
  
  initialize: function () {
    this.bindMethods('lz');
    this.schedules = [];
    this.listenTo(app, 'language-change', this.onLangChange);
    this.lzData = {};
    this.dictionary = this.getDictionary();
  },
  
  bindMethods: function () {
    return helpers.bindMethods(this, arguments);
  },
  
  getParent: function (viewTypeOrProp, value) {
    var prop = arguments.length > 1 ? viewTypeOrProp : 'viewType';
    value = arguments.length > 1 ? value : viewTypeOrProp;
    var parent = this.parent;
    while (parent && parent[prop] !== value) parent = parent.parent;
    if (!parent) console.error('could not find parent with '+ viewTypeOrProp);
    return parent;
  },
  getPage: function () {
    var parent = this.parent;
    while (!parent.pageType) parent = parent.parent;
    return parent;
  },
  
  // gets a dictionary path from this view or its parent tree
  getDictionary: function () {
    var dictionary = this.dictionary;
    var parent = this.parent;
    while (!dictionary && parent) {
      dictionary = parent.dictionary;
      parent = parent.parent;
    }
    return dictionary;
  },
  
  // used from templates, returns localized text wrapped in a span which text
  // is automatically replaced on languange change
  lz: function () {
    // copy args without killing optimization and add dictionary as first arg
    var args = new Array(arguments.length+1);
    args[0] = this.dictionary;
    for (var i = 1; i < args.length; i++) args[i] = arguments[i-1];
      
    var lzId = this.cid +'-'+ (this.lzId++);
    this.lzData[lzId] = args;
    
    var result = app.i18n.localize.apply(app.i18n, args);
    // if (args[2] && args[2]._isAMomentObject) console.log(result);
    
    return '<span data-lz-id="'+ lzId +'">'+ result +'</span>';
  },
  
  onLangChange: function () { // schedule an update of all localizable text 
    if (!this.el) return;
    // console.log('on lang change', this.cid, app.i18n.id);
    this.write(this.updateLocalizedContent, 'high');
  },
  updateLocalizedContent: function () { // updates all localizable text 
    // TODO: cleanup data for IDs that aren't used anymore 
    var elements = this.queryAll('[data-lz-id]');
    var id;
    for (var i = 0; i < elements.length; i++) {
      id = elements[i].getAttribute('data-lz-id');
      if (!this.lzData[id]) continue; // element is from a subview 
      
      elements[i].innerHTML =app.i18n.localize.apply(app.i18n, this.lzData[id]);
    }
  },
  
  escape: function (str) {
    return lodashEscape(str);
  },
  toDoubleDigit: function (val) {
    return (+val < 10) ? '0'+ val : ''+ val;
  },
  
  
  alert: function (message, options) {
    options = typeof message === 'object' ? message : (options || {});
    if (typeof message !== 'object') options.message = message;
    if (options.message) options.content = this.lz(options.message);
    options.context = this;
    return modalPopup.alert(options);
  },
  confirm: function (message, options) {
    options = typeof message === 'object' ? message : (options || {});
    if (typeof message !== 'object') options.message = message;
    if (options.message) options.content = this.lz(options.message);
    options.context = this;
    return modalPopup.confirm(options);
  },
  
  
  // rewrite remove to simply remove the element without taking the view apart
  remove: function (priority) {
    if (this.el && this.el.parentNode) {
      if (priority === 'now') this.el.parentNode.removeChild(this.el);
      else {
        this.write(function () {
          if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }, priority);
      }
    }
    // this.trigger('remove', this);
    return this;
  },
  
  
  isVisible: function (el, rect) { // whether an element is actually visible 
    el = el || this.el;
    rect = rect || el.getBoundingClientRect();
    if (!rect.width || !rect.height) return false;
    
    // check that element is inside the viewport 
    if (rect.top >= app.state.height) return false;
    if (rect.top + rect.height <= 0) return false;
    if (rect.left >= app.state.width) return false;
    if (rect.left + rect.width <= 0) return false;
    
    // see if element is not covered or scrolled away
    // var x = rect.left + rect.width / 2;
    // var y = rect.top + rect.height / 2;
    // var elOnPoint = document.elementFromPoint(x, y);
    // var visible = elOnPoint === el || el.contains(elOnPoint);
    // if (!visible) return false;
    
    return true;
  },
  
  
  raf: function (fn) {
    return ua.raf(fn.bind(this));
  },
  
  // ===========================================================================
  after: function (ms, fn, priority) {
    return this.writeAfter(ms, fn, priority);
  },
  
  // ===========================================================================
  readAfter: function (ms, fn) {
    return schedule.after(ms, fn, 'highest', this);
  },
  
  // ===========================================================================
  writeAfter: function (ms, fn, priority) {
    priority = priority === 'highest' ? 'high' : priority; // only after reads
    return schedule.after(ms, fn, priority, this);
  },
  
  
  // ===========================================================================
  // schedule a DOM read before the next frame draw and scheduled writes
  read: function (fn) {
    return schedule(fn, 'highest', this);
  },
  
  
  // ===========================================================================
  // schedule DOM write before the next frame draw and after all scheduled reads
  write: function (fn, priority) {
    priority = priority === 'highest' ? 'high' : priority; // only after reads
    return schedule(fn, priority, this);
  },
  
  
  // ===========================================================================
  // cancel scheduled execution
  unschedule: function (id) {
    schedule.unschedule(id);
    return this;
  },
  
  
  
  preventDefault: function (e) {
    if (e && typeof e.preventDefault === 'function') e.preventDefault(); 
    // if (e && typeof e.stopPropagation === 'function') e.stopPropagation(); 
    return false;
  },
});

var modalPopup = require('app/modal-popup/modal-popup');
