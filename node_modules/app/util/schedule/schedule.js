/*==========================================================================*\
  rAF-based scheduler for task throttling
  var id = schedule(fn, priority);
  schedule.unschedule(id); // remove the task if you changed your mind
  
  'high' and 'highest' priority tasks all run before the next frame together.
  'normal' and 'low' are only ran one per frame.
\*==========================================================================*/
"use strict";

var ua = require('app/util/ua/ua');

var loop = null; // rAF ID
var taskId = 1; // ID counter for new tasks
var queue = { lowest: [], low: [], normal: [], high: [], highest: [] };
var index = Object.create(null); // scheduled runs by IDs for quicker removal

var instantPriorities = ['highest', 'high', 'normal']; // running next frame
var deferredPriorities = ['low', 'lowest']; // tasks that can be delayed 

function run() {
  var i, n, task;
  var startTime = ua.now();
  var time;
  
  // high priority tasks run first and all at once 
  for (n = 0; n < instantPriorities.length; n++) {
    for (i = 0; i < queue[instantPriorities[n]].length; i++) {
      task = queue[instantPriorities[n]][i];
      delete index[task.id];
      if (task.fn) task.fn.call(task.context);
    }
    queue[instantPriorities[n]] = [];
  }
  
  
  // Run through all other queues, removing all items as 
  // we go through but stop after one with 'fn' is encountered.
  // Ones without 'fn' are tasks marked as removed 
  // so we simply shift() through them
  priorities_loop: for (i = 0; i < deferredPriorities.length; i++) {
    task = true;
    while (task) {
      
      // defer low priority tasks until next frame if we've spent enough time
      time = ua.now();
      if (time > startTime + 9) break priorities_loop;
      
      task = queue[deferredPriorities[i]].shift();
      if (task && task.fn) {
        delete index[task.id];
        task.fn.call(task.context);
      }
    }
  }
  
  loop = queue.highest.length || queue.high.length || queue.normal.length 
        || queue.low.length || queue.lowest.length ? ua.raf(run) : null;
}


module.exports = function (fn, priority, context, delay) {
  var id = taskId++;
  
  var task = {
    fn: fn,
    id: id,
    context: context || {},
  };
  
  
  if (delay) {
    task.timerId = setTimeout(function () {
      queue[priority || 'normal'].push(task);
      if (!loop) loop = ua.raf(run);
    }, delay);
  }
  else {
    queue[priority || 'normal'].push(task);
    if (!loop) loop = ua.raf(run);
  }
  
  index[id] = task;
  
  return id;
};



// =============================================================================
// shortcut for delayed schedule
// should be used instead of setTimeout
module.exports.after = function (delay, fn, priority, context) {
  return module.exports(fn, priority, context, delay);
};



// =============================================================================
// unschedule previously scheduled tasks by ID or an array of IDs 
module.exports.unschedule = function (IDs) {
  if (!IDs) return;
  if (typeof IDs !== 'object') IDs = [IDs];
  for (var i = 0, len = IDs.length; i < len; i++) {
    // remove reference to task's function so that it can be GC-ed.
    // We don't touch the actual queues here as the main runner
    // will remove these empty tasks more efficiently without splicing
    if (index[IDs[i]]) {
      delete index[IDs[i]].fn;
      delete index[IDs[i]].context;
      delete index[IDs[i]];
    }
  }
};


// =============================================================================
// clear all schedules 
module.exports._reset = function () {
  queue.highest = [];
  queue.high = [];
  queue.normal = [];
  queue.low = [];
  queue.lowest.length = [];
  for (var i in index) {
    delete index[i];
  }
  if (loop) ua.caf(loop);
};
