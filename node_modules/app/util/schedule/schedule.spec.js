"use strict";
var proxyquire = require('proxyquireify')(require);
var sinon = require('sinon');

var rafQueue = [];
var rafId = 1;
var uaMock = {
  raf: function (cb) {
    rafQueue.push(cb);
    return rafId++;
  },
  caf: function () {
    rafQueue = [];
  },
};

function nextFrame() { // run rAF callbacks
  var time = uaMock.now();
  // if any new rAFs got called, they'll run on next frame only 
  for (var i = 0, len = rafQueue.length; i < len; i++) {
    rafQueue[i](time);
  }
  for (i = 0; i < len; i++) rafQueue.shift();
}

require('app/util/schedule/schedule');
var schedule = proxyquire('app/util/schedule/schedule', {
  'app/util/ua/ua': uaMock,
});

describe('Scheduler', function () {
  beforeEach(function () {
    schedule._reset();
    rafQueue = [];
  });
  
  it("schedules execution with requestAnimationFrame", function () {
    var spy = sinon.spy();
    schedule(spy);
    nextFrame();
    expect(spy) .called;
  });
  
  it("executes in order of priority: highest, high, normal, low, lowest", 
                                                                  function () {
    var spy1 = sinon.spy();
    var spy2 = sinon.spy();
    var spy3 = sinon.spy();
    var spy4 = sinon.spy();
    var spy5 = sinon.spy();
    
    schedule(spy1, 'low');
    schedule(spy2, 'lowest');
    schedule(spy3, 'high');
    schedule(spy4, 'highest');
    schedule(spy5, 'normal');
    
    nextFrame();
    
    expect(spy4).calledBefore(spy3);
    expect(spy3).calledBefore(spy5);
    expect(spy5).calledBefore(spy1);
    expect(spy1).calledBefore(spy2);
  });
  
  it("sets `normal` priority by default", function () {
    var spy1 = sinon.spy();
    var spy2 = sinon.spy();
    var spy3 = sinon.spy();
    schedule(spy1, 'low');
    schedule(spy2);
    schedule(spy3, 'high');
    
    nextFrame();
    
    expect(spy2).calledBefore(spy1);
    expect(spy3).calledBefore(spy2);
  });
  
  it("defers low and lowest priority tasks to next frames if already spent "+
      "more than 9ms", function () {
    var clock = sinon.useFakeTimers();
    var originalNow = uaMock.now;
    uaMock.now = Date.now; // sinon doesn't mock performace.now
    
    var spy1 = sinon.spy(function () { clock.tick(8); });
    var spy2 = sinon.spy(function () { clock.tick(4000); });
    var spy3 = sinon.spy();
    var spy4 = sinon.spy();
    
    schedule(spy1, 'lowest');
    schedule(spy2, 'low');
    schedule(spy3, 'low');
    schedule(spy4, 'lowest');
    
    nextFrame();
    
    expect(spy2, '1: spy2 called').called;
    expect(spy1, '1: spy1 not called').not.called;
    expect(spy3, '1: spy3 not called').not.called;
    expect(spy4, '1: spy4 not called').not.called;
    
    nextFrame();
    
    expect(spy1, '2: spy1 called').called;
    expect(spy3, '2: spy3 called').called;
    expect(spy4, '2: spy4 called').called;
    
    clock.restore();
    uaMock.now = originalNow;
  });
  
  it("executes tasks with empty context if none was provided", function () {
    schedule(function () {
      var keys = Object.keys(this);
      expect(keys.length).to.equal(0);
    });
    rafQueue[0]();
  });
  
  it("allows scheduling with a delay (setTimeout replacement)", function () {
    var clock = sinon.useFakeTimers();
    var originalNow = uaMock.now;
    uaMock.now = Date.now; // sinon doesn't mock performace.now
    
    var spy = sinon.spy();
    schedule.after(1000, spy);
    expect(spy).not.called;
    nextFrame();
    expect(spy).not.called;
    clock.tick(700);
    nextFrame();
    expect(spy).not.called;
    clock.tick(300);
    nextFrame();
    expect(spy).called;
    
    clock.restore();
    uaMock.now = originalNow;
  });
  
  it("allows to unschedule tasks by task ID", function () {
    var spy = sinon.spy();
    var id = schedule(spy);
    schedule.unschedule(id);
    rafQueue[0]();
    expect(spy).not.called;
  });
});
