/*==========================================================================*\
  Switching between pages with transitions support
\*==========================================================================*/
"use strict";

var ViewSwitcher = require('app/util/view-switcher/view-switcher');

var app = require('app');
var schedule = require('app/util/schedule/schedule');
var ua = require('app/util/ua/ua');

var parents = {
  event: 'home',
  'event-category': 'event',
  'event-cart': 'event',
  'event-checkout': 'event-cart',
};

function isChildOf(parent, page) {
  while (parents[page]) {
    if (parents[page] === parent) return true;
    page = parents[page];
  }
  return false;
}
function getTransition(to, from) {
  var toType = to.pageType;
  var fromType = from.pageType;
  if (toType === fromType) { // same page type - possible horizontal transition
    if (typeof to.compare === 'function') return to.compare(from);
    else return 'normal-transition';
  }
  else { // check for forward/back transition 
    return isChildOf(fromType, toType) ? 'forward-transition' :
           isChildOf(toType, fromType) ? 'back-transition' : 
                                         'normal-transition';
  }
}

module.exports = ViewSwitcher.extend({
  initialize: function () {
    ViewSwitcher.prototype.initialize.apply(this, arguments);
    this.footer = document.getElementById('footer');
  },
  
  switcher: function (done, newView, oldView) {
    var self = this;
    var title = newView.pageTitle;
    var newEl = newView.el;
    // document.title = title ? title +' - '+ app.title : app.title;
    app.setTitle(title, newView.noTitleTranslation ? null
                                                   : newView.getDictionary());
    
    if (app.state.noTransitions) {
      schedule(function () {
        // var top = newView.pageType === 'home' ? newView.scroll.top : 0;
        app.view.restoreScroll(newView);
        // var top = newView.scroll.top || 0;
        // document.documentElement.scrollTop = top;
        // document.body.scrollTop = top;
      }, 'high');
    }
    else if (newView.pageType === 'home') {
      schedule(function () {
        newView.scroller.scrollTop = newView.scroll.top;
      }, 'high');
    }
    
    
    newEl.classList.remove('hidden', 'no-animation', 'active', 'inactive');
    
    schedule(function () {
      app.state.hiddenNav = false;
      if (newView.fixedFooter) {
        newView.fixedFooter.el.classList.remove('hidden');
        this.footer.appendChild(newView.fixedFooter.el);
        this.footer.classList.remove('hidden');
      }
      else {
        this.footer.classList.add('hidden');
      }
    }, 'normal', this);
    
    var transitionEndHandled = false;
    var onTransitionEnd = function () {
      if (transitionEndHandled) return;
      transitionEndHandled = true;
      if (newView === self.current && newView.onShow) newView.onShow();
      if (newView === self.current && newView.updateHeaderLogo) {
        newView.updateHeaderLogo();
      }
      schedule(function () {
        if (oldView.fixedFooter) oldView.fixedFooter.remove();
        if (newView === self.current) newEl.classList.add('active');
        
        // avoid a webkit bug with disappearing scrollbar
        // newEl.style[ua.css.transform] = 'translateY(0)';
      }, 'high');
      
      if (newView === self.current) done();
      if (oldView) oldView.el.classList.add('inactive');
    };
    
    schedule(function () {
      if (oldView) {
        app.state.pageTransition = getTransition(newView, oldView);
        
        oldView.el.classList.remove('no-animation', 'active');
        oldView.el.classList.add('hidden');
        if (oldView.fixedFooter) {
          oldView.fixedFooter.el.classList.add('hidden');
        }
        
        if (app.state.noTransitions) {
          newEl.classList.add('active');
          if (oldView.fixedFooter) oldView.fixedFooter.remove();
          if (newView === self.current && newView.onShow) newView.onShow();
          if (newView === self.current && newView.updateHeaderLogo) {
            newView.updateHeaderLogo();
          }
          done();
        }
        else {
          var callback = function () {
            newEl.removeEventListener(ua.events.animationEnd, callback, false);
            onTransitionEnd();
          };
          newEl.addEventListener(ua.events.animationEnd, callback, false);
          setTimeout(onTransitionEnd, 1000); // fallback just in case
        }
      }
      else {
        newEl.classList.add('no-animation', 'active');
        if (newView.onShow) newView.onShow();
        
        // avoid a webkit bug with disappearing scrollbar
        // if (!app.state.noTransitions && !app.state.splashState) {
        //   newEl.style[ua.css.transform] = 'translateY(0)';
        // }
        
        done();
      }
    }, 'high', this);

    // store an additional reference
    app.view.currentPage = newView;
  },
});
