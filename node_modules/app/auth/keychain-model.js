/*==========================================================================*\
  Keychain model storing all the user's login data 
\*==========================================================================*/
"use strict";

var app = require('app');
var debounce = require('lodash.debounce');

var EventKeysModel = require('app/base/base-model').extend({
  props: {
    id: 'number',
    email: 'any',
    password: 'any',
    verified: ['boolean', true, false],
    allowedHide: ['boolean', true, false],
    allowedDownload: ['boolean', true, false],
    optIn: ['boolean', true, true],
  },
});

var EventsCollection = require('app/base/base-collection').extend({
  model: EventKeysModel,
});

var CategoryKeychainModel = require('app/base/base-model').extend({
  props: {
    id: 'number',
    eid: 'number',
    password: 'any',
    verified: ['boolean', true, false],
  },
});

var CategoriesCollection = require('app/base/base-collection').extend({
  indexes: ['eid'],
  model: CategoryKeychainModel,
});

module.exports = require('app/base/base-model').extend({
  // extraProperties: 'ignore',
  props: {
    mtime: 'number',
  },
  
  collections: {
    events: EventsCollection,
    categories: CategoriesCollection,
  },
  
  derived: {
    
  },
  
  initialize: function () {
    this.store = debounce(this.store, 300);
    var stored = app.storage.keychain;
    if (stored) this.set(JSON.parse(stored));
    // this.events.reset();
    this.listenTo(app, 'storage:keychain', this.storageCallback);
  },
  
  clear: function (currentId) { // logout from all events except currently open
    var currentEventId = currentId;
    var changed = false;
    // var currentEventId = currentId || 
    //     (app.currentPage && app.currentPage.eventId);
    if (!currentEventId) {
      this.events.reset();
      this.categories.reset();
      changed = true;
    }
    else { // remove all but the current event
      var event, category;
      var remove = [];
      var i;
      
      // clear events
      for (i = 0; i < this.events.length; i++) {
        event = this.events.at(i);
        if (event.id !== currentEventId) remove.push(event.id);
      }
      if (remove.length) {
        this.events.remove(remove);
        changed = true;
      }
      
      // clear categories
      remove = [];
      for (i = 0; i < this.categories.length; i++) {
        category = this.categories.at(i);
        if (category.eid !== currentEventId) remove.push(category.id);
      }
      if (remove.length) {
        this.categories.remove(remove);
        changed = true;
      }
    }
    
    if (!changed) return;
    this.mtime = Date.now();
    this.store();
  },
  
  storageCallback: function (newData) {
    newData = JSON.parse(newData);
    if (!newData.mtime) return;
    if (newData.mtime > this.mtime) {
      this.set(newData);
      if (app.view.currentPage && app.view.currentPage.eventId) {
        var event = app.eventModels[app.view.currentPage.eventId];
        var keychain = this.events.get(event.id);
        if (event.name && event.locked) {
          if (!keychain || !keychain.verified || 
              (event.email && !keychain.email) || 
              (event.password && !keychain.password) ) {
            app.navigate('home');
          }
        }
      }
    }
  },
  
  confirmKeys: function (id, permissions) {
    permissions = permissions || [];
    var model = this.events.get(id);
    if (!model) return;
    var changed = !model.verified;
    model.verified = true;
    model.allowedHide = permissions.indexOf('image_hide') > -1;
    model.allowedDownload = permissions.indexOf('image_download') > -1;
    // if (changed) {
      this.mtime = Date.now();
      this.store();
    // }
    
    app.storage.lastUsedEmail = model.email;
  },
  saveEventKeys: function (event, email, password, optIn, verified) {
    var model = this.events.get(event.id);
    verified = !!verified;
    var changed = false;
    if (!model) {
      changed = true;
      this.events.add({
        id: event.id,
        email: email,
        password: password,
        verified: verified,
        optIn: optIn,
      });
    }
    else {
      changed = model.email !== email || model.password !== password ||
                model.verified !== verified || model.optIn !== optIn;
      model.set({
        email: email,
        password: password,
        verified: verified,
        optIn: optIn
      });
    }
    if (changed) {
      this.mtime = Date.now();
      this.store();
    }
  },
  removeEventKeys: function (eid) {
    if (!this.events.get(eid)) return;
    this.events.remove(eid);
    this.mtime = Date.now();
    this.store();
  },
  
  
  confirmCategory: function (id) {
    var model = this.categories.get(id);
    if (!model) return;
    model.verified = true;
    this.mtime = Date.now();
    this.store();
  },
  saveCategory: function (id, eid, password, verified) {
    var model = this.categories.get(id);
    verified = !!verified;
    var changed = false;
    if (!model) {
      changed = true;
      this.categories.add({
        id: id,
        eid: eid,
        password: password,
        verified: verified,
      });
    }
    else {
      changed = model.password !== password || model.verified !== verified;
      model.set({
        password: password,
        verified: verified,
      });
    }
    if (changed) {
      this.mtime = Date.now();
      this.store();
    }
  },
  removeCategory: function (id) {
    if (!this.categories.get(id)) return;
    this.categories.remove(id);
    this.mtime = Date.now();
    this.store();
  },
  
  store: function () {
    app.storage.keychain = JSON.stringify(this.serialize());
  },
});
