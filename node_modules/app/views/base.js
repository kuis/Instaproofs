/*==========================================================================*\
  Base view to be extended by all others
\*==========================================================================*/
"use strict";

var $ = require('jquery');
var app = require('app');
var dom = require('app/utils/dom');
var schedule = require('app/utils/schedule');
var ua = require('app/utils/ua');
var language = require('app/language');

module.exports = require('ampersand-view').extend({
  extraProperties: 'allow',
  language: language,
  $: function (selector) {
    return $(selector, this.el);
  },
  
  initialize: function () {
    this.schedules = [];
  },
  
  
  // rewrite remove to simply remove the element without taking the view apart
  remove: function (priority) {
    if (this.el && this.el.parentNode) {
      if (priority === 'now') this.el.parentNode.removeChild(this.el);
      else {
        this.scheduleWrite(function () {
          if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }, priority);
      }
    }
    // this.trigger('remove', this);
    return this;
  },
  
  
  // setTimeout with callback bound to this view =============================
  after: function (ms, fn) {
    return setTimeout(fn.bind(this), ms);
  },
  
  isVisible: function (el, rect) { // whether an element is actually visible 
    el = el || this.el;
    rect = rect || el.getBoundingClientRect();
    if (!rect.width || !rect.height) return false;
    
    // check that element is inside the viewport 
    if (rect.top >= app.state.height) return false;
    if (rect.top + rect.height <= 0) return false;
    if (rect.left >= app.state.width) return false;
    if (rect.left + rect.width <= 0) return false;
    
    // see if element is not covered or scrolled away
    var x = rect.left + rect.width / 2;
    var y = rect.top + rect.height / 2;
    var elOnPoint = document.elementFromPoint(x, y);
    var visible = elOnPoint === el || el.contains(elOnPoint);
    if (!visible) return false;
    
    return true;
  },
  
  
  // request animation frame with callback bound to this view ================
  raf: function (fn) {
    return ua.raf(fn.bind(this));
  },
  
  
  // run a function on next frame ============================================
  schedule: function (fn, priority) {
    var id = schedule(fn, priority, this);
    // this.schedules.push(id);
    return id;
  },
  
  // cancel scheduled run ====================================================
  unschedule: function (id) {
    schedule.unschedule(id);
    return this;
  },
  
  
  // schedule a DOM read before the next frame draw and scheduled writes ===== 
  scheduleRead: function (fn) {
    var id = dom.scheduleRead(fn, this);
    // this.schedules.push(id);
    return id;
  },
  
  
  // schedule DOM write before the next frame draw and after all scheduled reads
  scheduleWrite: function (fn, priority) {
    var id = dom.scheduleWrite(fn, priority, this);
    // this.schedules.push(id);
    return id;
  },
});
