/*==========================================================================*\
  List of events on the homepage
\*==========================================================================*/
"use strict";

var _ = require('underscore');

var Parent = require('app/views/base-view');
var EventsCollection = require('app/models/events-collection');
var EventGroupView = require('./events-group');

module.exports = Parent.extend({
  
  displayedCount: 0, // number of displayed events 
  pendingDraws: false, // schedule ID for pending draw operation
  
  initialize: function (ops) {
    Parent.prototype.initialize.apply(this, arguments);
    this.drawQueue = []; // queue of event groups to draw onto the page
    ops = ops || {};
    this.collection = new EventsCollection(null, {
      filter: ops.filter || 'all',
      sort: ops.sort || 'date',
    });
    this.groupViews = [];
    this.listenTo(this.collection, 'reset', this.reset);
    this.listenTo(this.collection, 'more', this.addEvents);
  },
  
  
  // reset the page for another set of events (e.g. filtering chagned) =======
  reset: function () {
    this.groupViewsMap = {};
    if (this.groupViews && this.groupViews.length) { // cleanup old views 
      for (var i = 0; i < this.groupViews.length; i++) {
        this.groupViews[i].remove(); 
        this.groupViews[i].stopListening();
      }
    }
    this.displayedCount = 0;
    this.addEvents();
  },
  
  
  // add newly loaded events to the page =====================================
  addEvents: function () {
    // if (req.reset || req.data && !req.data.offset) return;
    var newModels = this.collection.last(this.collection.length - 
                                         this.displayedCount);
    this.displayedCount += newModels.length;
    var self = this;
    var sortedBy = this.collection.sortedBy;
    var groups = _.groupBy(newModels, this.separators[sortedBy]);
    var newGroupViews = [];
    _.each(groups, function (group, key) {
      if (self.groupViewsMap[key]) {
        if (self.groupViewsMap[key].collection.length === 1
            || group.length === 1) {
          self.groupViewsMap[key].collection.add(group);
          self.groupViewsMap[key].updateLayout();
        }
        else {
          newGroupViews.push(new EventGroupView({ 
            collection: new EventsCollection(group, { sort: sortedBy }),
            sortedBy: sortedBy,
            key: key,
            parent: this,
            noHeader: true,
          }));
          self.groupViews.push(newGroupViews[newGroupViews.length-1]);
        }
      }
      else {
        newGroupViews.push(self.groupViewsMap[key] = new EventGroupView({ 
          collection: new EventsCollection(group, { sort: sortedBy }),
          sortedBy: sortedBy,
          parent: this,
          key: key,
        }));
        self.groupViews.push(newGroupViews[newGroupViews.length-1]);
      }
    });
    
    if (sortedBy === 'type') {
      newGroupViews = _.sortBy(newGroupViews, function (a) {
        return a.collection.at(0).type.toUpperCase();
      });
    }
    
    for (var i = 0; i < newGroupViews.length; i++) {
      newGroupViews[i].render();
      this.drawQueue.push(newGroupViews[i].el);
      if (!this.pendingDraws) {
        this.pendingDraws = this.scheduleWrite(this.drawEvents, 'normal', this);
      }
    }
  },
  
  
  // draw event groups one a time for better frame-rate ======================
  drawEvents: function () {
    this.pendingDraws = false;
    if (this.drawQueue.length) {
      this.el.appendChild(this.drawQueue[0]);
      this.drawQueue.shift();
    }
    if (this.drawQueue.length && !this.pendingDraws) {
      this.pendingDraws = this.scheduleWrite(this.drawEvents, 'normal', this);
    } 
  },
  
  
  // functions that separate events into groups ==============================
  separators: {
    date: function (event) {
      return event.date.month() +'-'+ event.date.year();
    },
    name: function (event) {
      return event.name.substr(0,1).toUpperCase();
    },
    type: function (event) {
      return event.type_id;
    },
  },
  
  // sorting comparators =====================================================
  comparators: {
    date: function (a, b) {
      return b.date - a.date;
    },
    name: function (a, b) {
      var aName = a.name.toUpperCase();
      var bName = b.name.toUpperCase();
      if (aName === bName) return b.date - a.date;
      if (aName > bName) return 1;
      if (aName < bName) return -1;
      return 0;
    },
    type: function (a, b) {
      var aType = a.type;
      var bType = b.type;
      if (aType === bType) return b.date.valueOf() - a.date.valueOf();
      else return a.type.toUpperCase() - b.type.toUpperCase();
    },
  },
});






