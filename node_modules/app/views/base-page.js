/*==========================================================================*\
  Base page view
\*==========================================================================*/
"use strict";

var app = require('app');
var ua = require('app/utils/ua');
var Parent = require('app/views/base-view');
var Footer = require('./global/footer');

module.exports = Parent.extend({
  
  nearBottomDistance: 800, // how far from the bottom do we trigger load more 
  isReady: false, // whether the page is fully setup and can be displayed

  subviews: {
    footer: {
      container: '.page-footer',
      constructor: Footer,
    },
  },
  initialize: function () {
    Parent.prototype.initialize.apply(this, arguments);
    this.readScroll = this.readScroll.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    
    // scroll handling data
    this.scroll = {
      top: 0, // last registered or handled scroll position
      lastTop: 0, // previously handled scroll position 
      bottom: 0, // last registered or handled scroll distance to bottom
      max: 0, // maximum amount of scroll possible with current content 
      pending: null, // schedule ID if scroll read or handl is scheduled
      hiddenNav: false, // whether header and footer bars should be hidden
    };
  },
  
  // register callback for 'ready' or execute it right away ==================
  ready: function (callback) {
    var self = this;
    if (this.isReady) callback.apply(this);
    else this.once('ready', function () {
      callback.apply(self);
    });
  },
  
  
  // set page as ready and trigger the event =================================
  triggerReady: function () {
    if (this.isReady) return;
    var self = this;
    setTimeout(function () {
      if (self.isReady) return;
      self.isReady = true;
      self.trigger('ready');
      if (!app.isReady) {
        app.isReady = true;
        app.trigger('ready');
      }
    }, ua.mobile ? 600 : 300);
  },
  
  handleEvent: function (e) {
    switch (e.type) {
      case 'scroll': 
        if (this.scroll.pending) this.unschedule(this.scroll.pending);
        this.scroll.pending = this.scheduleRead(this.readScroll);
        break;
    }
  },
  
  readScroll: function () {
    this.scroll.pending = false;
    var top = this.scroller.scrollTop;
    if (top === this.scroll.top || this !== app.currentPage) return;
    this.scroll.lastTop = this.scroll.top;
    this.scroll.top = top;
    this.scroll.max = this.scroller.scrollHeight - this.scroller.clientHeight;
    var bottom = this.scroll.bottom = this.scroll.max - top;
    this.scroll.hiddenNav = top > this.scroll.lastTop && top > 1 && bottom > 1
                            && top + bottom >= 1000;
    
    if (this.onScroll || 
        this.onNearBottom && bottom <= this.nearBottomDistance ||
        ua.ios && (!top || !bottom) || 
        this.scroll.hiddenNav !== app.state.hiddenNav) {
      this.scroll.pending = this.scheduleWrite(this.handleScroll, 'normal');
    }
    
    app.state.scrolling = true;
    clearTimeout(this.scrollTimer);
    this.scrollTimer = setTimeout(app.view.removeScrollingClass, 250);
  },
  handleScroll: function () {
    this.scroll.pending = false;
    if (this !== app.currentPage) return;
    
    var el = this.scroller;
    
    if (this.onNearBottom && this.scroll.bottom <= this.nearBottomDistance) {
      this.onNearBottom(this.scroll.bottom, this.scroll.top);
    }
    
    // Make sure that content area is always scrolled by at least 1px
    // from top or bottom so that the whole viewport is never scrolled - only
    // content area
    if (ua.ios) {
      if (!this.scroll.top) el.scrollTop = 1;
      else if (!this.scroll.bottom) el.scrollTop = this.scroll.max - 1;
    }
    
    app.state.hiddenNav = this.scroll.hiddenNav;
    if (this.onScroll) this.onScroll(this.scroll.top, this.scroll.lastTop);
  },
  
  
  render: function () {
    this.renderWithTemplate(this);
    this.scroller = this.el;
    // this.scroller = this.el.firstChild;
    
    if (!app.state.noTransitions) {
      this.scroller.addEventListener('scroll', this, false);
      if (ua.ios) this.readScroll();
    }
  },
  
  // called every time a page is re-opened ===================================
  reset: function () {
    return this;
  },
  
  
  // sets page title and puts it into app's title if the page is active 
  setTitle: function (title) {
    this.pageTitle = title;
    if (this.el && this.el.parentNode) {
      document.title = title ? title +' - '+ app.title : app.title;
    }
  },
  
  // register keyboard handlers
  registerKeyboardShortcuts: function () {
    /*
    var self = this;
    _.each(this.keyboardShortcuts, function (value, k) {
        // register key handler scoped to this page
        key(k, self.cid, _.bind(self[value], self));
    });
    key.setScope(this.cid);
    */
  },
  unregisterKeyboardShortcuts: function () {
    //key.deleteScope(this.cid);
  },
});
