/*==========================================================================*\
  Base view to be extended by all others
\*==========================================================================*/
"use strict";

var app = require('app');
var dom = require('app/utils/dom');
var schedule = require('app/utils/schedule');
var ua = require('app/utils/ua');
var i18n = require('app/i18n/i18n');
var _ = require('underscore');

module.exports = require('ampersand-view').extend({
  // extraProperties: 'allow',
  props: {
    // list of data used for localizable chunks of content 
    lzData: { type: 'object', default: function () { return {}; }},
    lzId: ['number', true, 0],
  },
  
  initialize: function () {
    _.bindAll(this, 'lz');
    this.schedules = [];
    this.listenTo(i18n, 'select', this.onLangChange);
    this.lzData = {};
    this.dictionary = this.getDictionary();
  },
  
  // gets a dictionary path from this view or its parent tree
  getDictionary: function () {
    var dictionary = this.dictionary;
    var parent = this.parent;
    while (!dictionary && parent) {
      dictionary = parent.dictionary;
      parent = parent.parent;
    }
    return dictionary;
  },
  
  // used from templates, returns localized text wrapped in a span which value
  // is automatically replaced on languange change
  lz: function () {
    // copy args without killing optimization and add dictionary as first arg
    var args = new Array(arguments.length+1);
    args[0] = this.dictionary;
    for (var i = 1; i < args.length; i++) args[i] = arguments[i-1];
      
    var lzId = this.cid +'-'+ (this.lzId++);
    this.lzData[lzId] = args;
    
    var result = i18n.localize.apply(i18n, args);
    // if (args[2] && args[2]._isAMomentObject) console.log(result);
    
    return '<span data-lz-id="'+ lzId +'">'+ result +'</span>';
  },
  
  onLangChange: function () { // schedule an update of all localizable text 
    if (!this.el) return;
    // console.log('on lang change', this.cid, i18n.id);
    this.scheduleWrite(this.updateLocalizedContent, 'high');
  },
  updateLocalizedContent: function () { // updates all localizable text 
    // Possible TODO: cleanup data for IDs that aren't used anymore 
    var elements = this.queryAll('[data-lz-id]');
    var id;
    for (var i = 0; i < elements.length; i++) {
      id = elements[i].getAttribute('data-lz-id');
      if (!this.lzData[id]) continue; // element is from a subview 
      
      elements[i].innerHTML = i18n.localize.apply(i18n, this.lzData[id]);
    }
  },
  
  escape: function (str) {
    return _.escape(str);
  },
  
  
  // rewrite remove to simply remove the element without taking the view apart
  remove: function (priority) {
    if (this.el && this.el.parentNode) {
      if (priority === 'now') this.el.parentNode.removeChild(this.el);
      else {
        this.scheduleWrite(function () {
          if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }, priority);
      }
    }
    // this.trigger('remove', this);
    return this;
  },
  
  
  // setTimeout with callback bound to this view =============================
  after: function (ms, fn) {
    return setTimeout(fn.bind(this), ms);
  },
  
  isVisible: function (el, rect) { // whether an element is actually visible 
    el = el || this.el;
    rect = rect || el.getBoundingClientRect();
    if (!rect.width || !rect.height) return false;
    
    // check that element is inside the viewport 
    if (rect.top >= app.state.height) return false;
    if (rect.top + rect.height <= 0) return false;
    if (rect.left >= app.state.width) return false;
    if (rect.left + rect.width <= 0) return false;
    
    // see if element is not covered or scrolled away
    var x = rect.left + rect.width / 2;
    var y = rect.top + rect.height / 2;
    var elOnPoint = document.elementFromPoint(x, y);
    var visible = elOnPoint === el || el.contains(elOnPoint);
    if (!visible) return false;
    
    return true;
  },
  
  
  // request animation frame with callback bound to this view ================
  raf: function (fn) {
    return ua.raf(fn.bind(this));
  },
  
  
  // run a function on next frame ============================================
  schedule: function (fn, priority) {
    var id = schedule(fn, priority, this);
    // this.schedules.push(id);
    return id;
  },
  
  // cancel scheduled run ====================================================
  unschedule: function (id) {
    schedule.unschedule(id);
    return this;
  },
  
  
  // schedule a DOM read before the next frame draw and scheduled writes ===== 
  scheduleRead: function (fn) {
    var id = dom.scheduleRead(fn, this);
    // this.schedules.push(id);
    return id;
  },
  
  
  // schedule DOM write before the next frame draw and after all scheduled reads
  scheduleWrite: function (fn, priority) {
    var id = dom.scheduleWrite(fn, priority, this);
    // this.schedules.push(id);
    return id;
  },
});
