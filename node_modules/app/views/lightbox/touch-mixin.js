/*==========================================================================*\
  Lightbox Slidshow Functionality
\*==========================================================================*/
"use strict";
var app = require('app');
var ua = require('app/utils/ua');

var animation; // currently performing non-native animation
var easings; // list of easing functions for non-native animation
var gesture; // info on currently tracked gesture 
var lastDirection = 0; // direction of the last successful swipe (1/-1)
var now = ua.now;
var rolling = false; // whether a swipe animation is in progress 
var sliderPos = 0; // current slider position in steps
var timerID = null; // timer for animation end fallback 

module.exports = {
  
  initTouch: function () {
    var self = this;
    this.tick = this.tick.bind(this);
    this.onAnimationEnd = this.onAnimationEnd.bind(this);
    
    if (ua.events.transitionEnd) {
      this.el.addEventListener(ua.events.transitionEnd, function (e) {
        if (e.target !== self.current.el) return;
        self.onAnimationEnd();
      });
    }
  },
  
  onTouchStart: function (e) {
    if (!this.displayed || rolling) return;
    
    if (rolling) { // disable tap
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    
    this.mouseRest = false;
    this.noUI = false;
    
    gesture = {};
    
    gesture.moved = false; // indicates whether enough movement's been done 
    gesture.touchPos = gesture.startPos = e.touches[0].clientX;
    gesture.time = now();
    gesture.velocity = 0;
  },
  onTouchMove: function (e) {
    if (this.displayed) e.preventDefault();
    if (!this.displayed || rolling || !gesture) return;
    
    
    var g = gesture;
    var touchPos = e.touches[0].clientX;
    var deltaPos = touchPos - g.touchPos;
    var time = now();
    var velocity;
    
    g.totalDelta = touchPos - g.startPos;
    g.touchPos = touchPos;
    velocity = deltaPos / (1 + time - g.time); // velocity of the last move 
    g.time = time;
    g.velocity = 0.8 * velocity + 0.2 * g.velocity; // moving average filter 
    
    // wait for at least 10px of movement
    if (!g.moved && Math.abs(g.touchPos - g.startPos) <= 10) {
      return;
    }
    
    // this.el.classList.remove('cross-fade');

    g.moved = true;
    g.sliderX = sliderPos * app.state.width + g.totalDelta;
    this.translate(g.sliderX);
  },
  onTouchEnd: function () {
    if (!this.displayed || rolling || !gesture) return;
    
    var g = gesture; // current scrolling gesture's data

    // if (!g.moved || Math.abs(g.velocity) < 150) { // not enough velocity 
    if (!g.moved) {
      gesture = null;
      return;
    }
    
    var direction = g.direction = g.velocity > 0 ? 1 : -1;
    lastDirection = direction < 0 ? 'forward' : 'back';
    sliderPos += direction;
    g.targetX = (sliderPos * app.state.width);
    
    g.velocity = Math.abs(g.velocity);
    if (g.velocity > 2.5) g.velocity = 2;
    var duration = (app.state.width - Math.abs(g.totalDelta)) / g.velocity /1.5;
    var easing = 'ease-out';
    if (duration > 300) {
      duration = 300;
      easing = 'ease';
    }
    // if (duration < 100) duration = 100;
    this.slideTo(g.targetX, duration, null, easing);
    
    clearTimeout(this.mouseRestTimer);
    this.mouseRestTimer = setTimeout(this.onMouseRest, this.mouseRestSpeed);
  },

  slideTo: function (pos, duration, cb, easing) {
    var g = gesture || {};
    gesture = null;
    rolling = true;
    
    if (ua.css.transitionDuration) {
      easing = easing || 'ease';
      this.current.el.style[ua.css.transitionDuration] = duration +'ms';
      this.prev[0].el.style[ua.css.transitionDuration] = duration +'ms';
      this.next[0].el.style[ua.css.transitionDuration] = duration +'ms';
      if (ua.css.transitionEasing) {
        this.current.el.style[ua.css.transitionEasing] = easing;
        this.prev[0].el.style[ua.css.transitionEasing] = easing;
        this.next[0].el.style[ua.css.transitionEasing] = easing;
      }
      this.translate(pos);
      clearTimeout(timerID);
      timerID = setTimeout(this.onAnimationEnd, duration + 50);
    }
    else {
      animation = {
        startX: g.sliderX || sliderPos * app.state.width,
        targetX: pos,
        startTime: now(),
        duration: duration,
        cb: cb,
        easing: gesture ? easings.easeOutCubic : easings.easeInOutCubic,
      };
      animation.endTime = animation.startTime + duration;
      
      ua.raf(this.tick);
    }
    
  },
  tick: function (time) {
    if (!rolling || !this.displayed) return;
    var anim = animation;
    time = Math.min(ua.performanceNow && time ? time : now(), anim.endTime);
    
    // set position in animation's timeframe 
    var pos = (time - anim.startTime) / anim.duration;
    
    if (time < anim.endTime) { // process new frame and schedule the next one 
      var x = anim.startX + anim.easing(pos) * (anim.targetX - anim.startX);
      this.translate(x);
      
      ua.raf(this.tick);
    }
    else {
      this.translate(anim.targetX);
      this.after(50, function () {
        if (anim.cb) anim.cb();
        
        this.trigger('stop');
        this.updateSlides();
        // if (App.ua.desktop) {
        //   scrollGrid();
        // }
        this.current.el.style[ua.css.transitionDuration] = '0ms';
        this.prev[0].el.style[ua.css.transitionDuration] = '0ms';
        this.next[0].el.style[ua.css.transitionDuration] = '0ms';
        
        animation = null;
        rolling = false;
      }, 50);
    }
  },
  
  onAnimationEnd: function () {
    clearTimeout(timerID);
    if (!rolling) return;
    this.trigger('stop');
    this.current.el.style[ua.css.transitionDuration] = '0ms';
    this.prev[0].el.style[ua.css.transitionDuration] = '0ms';
    this.next[0].el.style[ua.css.transitionDuration] = '0ms';
    
    this.updateSlides();
    // if (App.ua.desktop) {
    //   scrollGrid();
    // }
    rolling = false;
    
    this[lastDirection]();
    
    // this.el.classList.add('cross-fade');
    sliderPos = 0;
    this.translate(0);
  },

  translate: function (x) {
    var prevX = x > 0 ? x - app.state.width : '-100%';
    var nextX = x < 0 ? x + app.state.width : '100%';
    if (ua.css.transform) {
      this.current.el.style[ua.css.transform] = 'translate3d('+ x +'px,0,0)';
      this.prev[0].el.style[ua.css.transform] = 'translate3d('+prevX +'px,0,0)';
      this.next[0].el.style[ua.css.transform] = 'translate3d('+nextX +'px,0,0)';
    }
    else {
      this.current.el.style.left = x +'px';
      this.prev[0].el.style.left = prevX +'px';
      this.next[0].el.style.left = nextX +'px';
    }
  }
};


easings = {
  easeInQuad: function (pos) {
    return Math.pow(pos, 2);
  },

  easeOutQuad: function (pos) {
    return -(Math.pow((pos - 1), 2) - 1);
  },

  easeInOutQuad: function (pos) {
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,2);}
    return -0.5 * ((pos -= 2) * pos - 2);
  },

  easeInCubic: function (pos) {
    return Math.pow(pos, 3);
  },

  easeOutCubic: function (pos) {
    return (Math.pow((pos - 1), 3) + 1);
  },

  easeInOutCubic: function (pos) {
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,3);}
    return 0.5 * (Math.pow((pos - 2),3) + 2);
  },

  easeInQuart: function (pos) {
    return Math.pow(pos, 4);
  },

  easeOutQuart: function (pos) {
    return -(Math.pow((pos - 1), 4) - 1);
  },

  easeInOutQuart: function (pos) {
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
    return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
  },

  easeInQuint: function (pos) {
    return Math.pow(pos, 5);
  },

  easeOutQuint: function (pos) {
    return (Math.pow((pos - 1), 5) + 1);
  },

  easeInOutQuint: function (pos) {
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,5);}
    return 0.5 * (Math.pow((pos - 2),5) + 2);
  },

  easeInSine: function (pos) {
    return -Math.cos(pos * (Math.PI / 2)) + 1;
  },

  easeOutSine: function (pos) {
    return Math.sin(pos * (Math.PI / 2));
  },

  easeInOutSine: function (pos) {
    return (-0.5 * (Math.cos(Math.PI * pos) - 1));
  },

  easeInExpo: function (pos) {
    return (pos === 0) ? 0 : Math.pow(2, 10 * (pos - 1));
  },

  easeOutExpo: function (pos) {
    return (pos === 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
  },

  easeInOutExpo: function (pos) {
    if (pos === 0) {return 0;}
    if (pos === 1) {return 1;}
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(2,10 * (pos - 1));}
    return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
  },

  easeInCirc: function (pos) {
    return -(Math.sqrt(1 - (pos * pos)) - 1);
  },

  easeOutCirc: function (pos) {
    return Math.sqrt(1 - Math.pow((pos - 1), 2));
  },

  easeInOutCirc: function (pos) {
    if ((pos /= 0.5) < 1) {return -0.5 * (Math.sqrt(1 - pos * pos) - 1);}
    return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
  },

  easeOutBounce: function (pos) {
    if ((pos) < (1 / 2.75)) {
      return (7.5625 * pos * pos);
    } else if (pos < (2 / 2.75)) {
      return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
    } else if (pos < (2.5 / 2.75)) {
      return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
    } else {
      return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
    }
  },

  easeInBack: function (pos) {
    var s = 1.70158;
    return (pos) * pos * ((s + 1) * pos - s);
  },

  easeOutBack: function (pos) {
    var s = 1.70158;
    return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
  },

  easeInOutBack: function (pos) {
    var s = 1.70158;
    if ((pos /= 0.5) < 1) {
        return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));}
    return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
  },

  elastic: function (pos) {
    return -1 * Math.pow(4,-8 * pos) * 
           Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
  },

  swingFromTo: function (pos) {
    var s = 1.70158;
    return ((pos /= 0.5) < 1) ? 
        0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) :
        0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
  },

  swingFrom: function (pos) {
    var s = 1.70158;
    return pos * pos * ((s + 1) * pos - s);
  },

  swingTo: function (pos) {
    var s = 1.70158;
    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
  },

  bounce: function (pos) {
    if (pos < (1 / 2.75)) {
      return (7.5625 * pos * pos);
    } else if (pos < (2 / 2.75)) {
      return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
    } else if (pos < (2.5 / 2.75)) {
      return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
    } else {
      return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
    }
  },

  bouncePast: function (pos) {
    if (pos < (1 / 2.75)) {
      return (7.5625 * pos * pos);
    } else if (pos < (2 / 2.75)) {
      return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
    } else if (pos < (2.5 / 2.75)) {
      return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
    } else {
      return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
    }
  },

  easeFromTo: function (pos) {
    if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
    return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
  },

  easeFrom: function (pos) {
    return Math.pow(pos,4);
  },

  easeTo: function (pos) {
    return Math.pow(pos,0.25);
  },
  
  linear: function (pos) {
    return pos;
  },
};
